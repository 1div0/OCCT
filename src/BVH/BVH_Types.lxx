// Created on: 2013-12-20
// Created by: Denis BOGOLEPOV
// Copyright (c) 2013-2014 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

namespace BVH
{
  template<class T, int N> struct VecComp
  {
    // Not implemented
  };

  template<class T> struct VecComp<T, 2>
  {
    typedef typename BVH::VectorType<T, 2>::Type BVH_Vec2t;

    static T Get (const BVH_Vec2t&       theVec,
                  const Standard_Integer theAxis)
    {
      return theAxis == 0 ? theVec.x() : theVec.y();
    }
  };

  template<class T> struct VecComp<T, 3>
  {
    typedef typename BVH::VectorType<T, 3>::Type BVH_Vec3t;

    static T Get (const BVH_Vec3t&       theVec,
                  const Standard_Integer theAxis)
    {
      return theAxis == 0 ? theVec.x() : ( theAxis == 1 ? theVec.y() : theVec.z() );
    }
  };

  template<class T> struct VecComp<T, 4>
  {
    typedef typename BVH::VectorType<T, 4>::Type BVH_Vec4t;

    static T Get (const BVH_Vec4t&       theVec,
                  const Standard_Integer theAxis)
    {
      return theAxis == 0
           ? theVec.x()
           : (theAxis == 1 ? theVec.y() : ( theAxis == 2 ? theVec.z() : theVec.w() ));
    }
  };

  template<class T, int N = 1> struct ArrayOp
  {
    typedef typename BVH::ArrayType<T, N>::Type BVH_ArrayNt;

    static inline
    const typename BVH::VectorType<T, N>::Type& Value (const BVH_ArrayNt&     theArray,
                                                       const Standard_Integer theIndex)
    {
    #ifdef _BVH_USE_STD_VECTOR_
      return theArray[theIndex];
    #else
      return theArray.Value (theIndex);
    #endif
    }

    static inline
    typename BVH::VectorType<T, N>::Type& ChangeValue (BVH_ArrayNt&           theArray,
                                                       const Standard_Integer theIndex)
    {
    #ifdef _BVH_USE_STD_VECTOR_
      return theArray[theIndex];
    #else
      return theArray.ChangeValue (theIndex);
    #endif
    }

    static inline void Append (BVH_ArrayNt& theArray,
                               const typename BVH::VectorType<T, N>::Type& theElement)
    {
    #ifdef _BVH_USE_STD_VECTOR_
      theArray.push_back (theElement);
    #else
      theArray.Append (theElement);
    #endif
    }

    static inline Standard_Integer Size (const BVH_ArrayNt& theArray)
    {
    #ifdef _BVH_USE_STD_VECTOR_
      return static_cast<Standard_Integer> (theArray.size());
    #else
      return static_cast<Standard_Integer> (theArray.Size());
    #endif
    }

    static inline void Clear (BVH_ArrayNt& theArray)
    {
    #ifdef _BVH_USE_STD_VECTOR_
      theArray.clear();
    #else
      theArray.Clear();
    #endif
    }
  };
}
