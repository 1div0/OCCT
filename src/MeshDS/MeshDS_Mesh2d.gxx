// File:	MeshDS_Mesh2d.gxx
// Created:	Tue May 11 16:01:57 1993
// Author:	Didier PIFFAULT
//		<dpf@nonox>


//=======================================================================
//function : MeshDS_Mesh2d
//purpose  : 
//=======================================================================
MeshDS_Mesh2d::MeshDS_Mesh2d(const MeshDS_BaseAllocator& theAlloc,
			     const Standard_Integer NodeNumber)
     : myNodes(NodeNumber+3),
       myDelNodes(theAlloc),
       myLinks(NodeNumber*3), 
       myDelLinks(theAlloc),
       myElements(NodeNumber*2),
       // Not_Debuged_Yet myDelElements(theAlloc),
       myElemOfDomain(NodeNumber*2,theAlloc),
       myLinkOfDomain(NodeNumber*2,theAlloc)
{
  myAllocator = theAlloc;
}

//=======================================================================
//function : AddNode
//purpose  : 
//=======================================================================
Standard_Integer  MeshDS_Mesh2d::AddNode(const Node& theNode)
{
  Standard_Integer NodeIndex=myNodes.FindIndex(theNode);
  if (NodeIndex>0 && !myDelNodes.IsEmpty()) {
    if (myNodes.FindKey(NodeIndex).Movability()==MeshDS_Deleted)
      NodeIndex=0;
  }
  if (NodeIndex<=0) {
    MeshDS_ListOfInteger thelist(myAllocator);
    if (!myDelNodes.IsEmpty()) {
      NodeIndex=myDelNodes.First();
      myNodes.Substitute(NodeIndex, theNode, thelist);
      myDelNodes.RemoveFirst();
    }
    else {
      NodeIndex=myNodes.Add(theNode, thelist);
    }
  }
  return NodeIndex;
}

//=======================================================================
//function : GetNode
//purpose  : 
//=======================================================================
const Node&  MeshDS_Mesh2d::GetNode(const Standard_Integer Index)
{
  return myNodes.FindKey(Index);
}

//=======================================================================
//function : GetNodeList
//purpose  : 
//=======================================================================
const MeshDS_ListOfInteger& MeshDS_Mesh2d::GetNodeList(const Standard_Integer Index)
{
  return myNodes.FindFromIndex(Index);
}

//=======================================================================
//function : ForceRemoveNode
//purpose  : 
//=======================================================================
void  MeshDS_Mesh2d::ForceRemoveNode(const Standard_Integer Index)
{
  //Warning, the static cast from const& to & is called for
  //performance reasons. This is applicable only in case if later
  //modification of element (field movability) does not influent on
  //has calculation.
  Node& vref=(Node&)myNodes.FindKey(Index);
  if ( myNodes.FindFromIndex(Index).Extent()==0) {
    vref.SetMovability(MeshDS_Deleted);
    myDelNodes.Append(Index);
  }
}

//=======================================================================
//function : ReplaceNodes
//purpose  : 
//=======================================================================
void  MeshDS_Mesh2d::ReplaceNodes(const MeshDS_IDMapOfNode& NewNodes)
{
  if (NewNodes.IsEmpty() || NewNodes.Extent() != myNodes.Extent())
    return;
  /*for (Standard_Integer i = 1; i <= myNodes.Extent(); i++)
     ForceRemoveNode(i);*/

  myNodes.Assign(NewNodes);
}

//=======================================================================
//function : ForceRemoveLink
//purpose  : 
//=======================================================================
void  MeshDS_Mesh2d::ForceRemoveLink(const Standard_Integer Index)
{
  //Warning, the static cast from const& to & is called for
  //performance reasons. This is applicable only in case if later
  //modification of element (field movability) does not influent on
  //has calculation.
  Link& lref=(Link&)myLinks.FindKey(Index);
  if (lref.Movability()!=MeshDS_Deleted) {
    if (myLinks.FindFromIndex(Index).Extent()==0) {
      MeshDS_ListOfInteger::Iterator tit;
      MeshDS_ListOfInteger& aList1 = myNodes(lref.FirstNode());
      for(tit.Init(aList1); tit.More(); tit.Next()){
	if (tit.Value()==Index) {
	  aList1.Remove(tit);
	  break;
	}
      }
      
      MeshDS_ListOfInteger& aList2 = myNodes(lref.LastNode());
      for(tit.Init(aList2); tit.More(); tit.Next()){
	if (tit.Value()==Index) {
	  aList2.Remove(tit);
	  break;
	}
      }
      myLinkOfDomain.Remove(Index);
      lref.SetMovability(MeshDS_Deleted);
      myDelLinks.Append(Index);
    }
  }
}

//=======================================================================
//function : RemoveNode
//purpose  : 
//=======================================================================
void  MeshDS_Mesh2d::RemoveNode(const Standard_Integer Index)
{
  //Warning, the static cast from const& to & is called for
  //performance reasons. This is applicable only in case if later
  //modification of element (field movability) does not influent on
  //has calculation.
  Node& vref=(Node&)myNodes.FindKey(Index);
  if (vref.Movability()==MeshDS_Free &&
      myNodes.FindFromIndex(Index).Extent()==0) {
      vref.SetMovability(MeshDS_Deleted);
      myDelNodes.Append(Index);
  }
}

//=======================================================================
//function : MoveNode
//purpose  : 
//=======================================================================
Standard_Boolean MeshDS_Mesh2d::MoveNode(const Standard_Integer Index, 
					 const Node& newNode)
{
  if (myNodes.FindIndex(newNode)==0) {
    Node vref(myNodes.FindKey(Index));
    const MeshDS_ListOfInteger& refLink=myNodes(Index);
    vref.SetMovability(MeshDS_Deleted);
    myNodes.Substitute(Index, vref, refLink);
    myNodes.Substitute(Index, newNode, refLink);
    return Standard_True;
  }
  return Standard_False;
}

//=======================================================================
//function : NbNodes
//purpose  : 
//=======================================================================
Standard_Integer  MeshDS_Mesh2d::NbNodes()const
{
  return myNodes.Extent();
}

//=======================================================================
//function : AddLink
//purpose  : 
//=======================================================================
Standard_Integer  MeshDS_Mesh2d::AddLink(const Link& theLink)
{
  Standard_Integer LinkIndex=myLinks.FindIndex(theLink);
  if (LinkIndex<=0) {
    MeshDS_PairOfIndex aPair;
    if (!myDelLinks.IsEmpty()) {
      LinkIndex=myDelLinks.First();
      myLinks.Substitute(LinkIndex, theLink, aPair);
      myDelLinks.RemoveFirst();
    }
    else {
      LinkIndex=myLinks.Add(theLink, aPair);
    }
    myNodes(theLink.FirstNode()).Append(Abs(LinkIndex));
    myNodes(theLink.LastNode()).Append(Abs(LinkIndex));
    myLinkOfDomain.Add(LinkIndex);
  }
  else if (!theLink.SameOrientation(myLinks.FindKey(LinkIndex))) 
    LinkIndex=-LinkIndex;

  return LinkIndex;
}

//=======================================================================
//function : GetLink
//purpose  : 
//=======================================================================
const Link&  MeshDS_Mesh2d::GetLink(const Standard_Integer Index)
{
  return myLinks.FindKey(Index);
}

//=======================================================================
//function : RemoveLink
//purpose  : 
//=======================================================================
void  MeshDS_Mesh2d::RemoveLink(const Standard_Integer Index)
{
  //Warning, the static cast from const& to & is called for
  //performance reasons. This is applicable only in case if later
  //modification of element (field movability) does not influent on
  //has calculation.
  Link& lref=(Link&)myLinks.FindKey(Index);
  if (lref.Movability()!=MeshDS_Deleted) {
    if (lref.Movability()==MeshDS_Free && 
	myLinks.FindFromIndex(Index).Extent()==0) {
      MeshDS_ListOfInteger::Iterator tit;
      MeshDS_ListOfInteger& aList1 = myNodes(lref.FirstNode());
      for(tit.Init(aList1); tit.More(); tit.Next()){
	if (tit.Value()==Index) {
	  aList1.Remove(tit);
	  break;
	}
      }
      MeshDS_ListOfInteger& aList2 = myNodes(lref.LastNode());
      for(tit.Init(aList2); tit.More(); tit.Next()){
	if (tit.Value()==Index) {
	  aList2.Remove(tit);
	  break;
	}
      }
      myLinkOfDomain.Remove(Index);
      lref.SetMovability(MeshDS_Deleted);
      myDelLinks.Append(Index);
    }
  }
}

//=======================================================================
//function : SubstituteLink
//purpose  : 
//=======================================================================
Standard_Boolean  MeshDS_Mesh2d::SubstituteLink(const Standard_Integer Index,
						const Link& newLink)
{
  //MeshDS_ListOfInteger thelist(myAllocator);
  MeshDS_PairOfIndex aPair;
  Link lref=myLinks.FindKey(Index);
  if (lref.Movability()==MeshDS_Deleted) 
    myLinks.Substitute(Index, newLink, aPair);
  else {
    if (myLinks.FindIndex(newLink)!=0) 
      return Standard_False;

    lref.SetMovability(MeshDS_Deleted);
    myLinks.Substitute(Index, lref, aPair);

    MeshDS_ListOfInteger::Iterator tit;
    for(tit.Init(myNodes(lref.FirstNode())); tit.More(); tit.Next()){
      if (tit.Value()==Index) {
	myNodes(lref.FirstNode()).Remove(tit);
	break;
      }
    }
    for(tit.Init(myNodes(lref.LastNode())); tit.More(); tit.Next()){
      if (tit.Value()==Index) {
	myNodes(lref.LastNode()).Remove(tit);
	break;
      }
    }
    myLinks.Substitute(Index, newLink, aPair);
    myNodes(newLink.FirstNode()).Append(Abs(Index));
    myNodes(newLink.LastNode()).Append(Abs(Index));
  }
  return Standard_True;
}

//=======================================================================
//function : NbLinks
//purpose  : 
//=======================================================================
Standard_Integer  MeshDS_Mesh2d::NbLinks()const
{
  return myLinks.Extent();
}

//=======================================================================
//function : AddElement
//purpose  : 
//=======================================================================
Standard_Integer  MeshDS_Mesh2d::AddElement(const Element& theElement)
{
  Standard_Integer ElemIndex=myElements.FindIndex(theElement);

  if (ElemIndex<=0) {
    /* Not_Debuged_Yet 
    if (!myDelElements.IsEmpty()) {
      ElemIndex=myDelElements.First();
      myElements.Substitute(ElemIndex, theElement);
      myDelElements.RemoveFirst();
    }
    else */
      ElemIndex=myElements.Add(theElement);
    
    myElemOfDomain.Add(ElemIndex);

    Standard_Integer ed1, ed2, ed3;
    Standard_Boolean or1, or2, or3;
    theElement.Edges(ed1, ed2, ed3, or1, or2, or3);
    myLinks(ed1).Append(ElemIndex);
    myLinks(ed2).Append(ElemIndex);
    myLinks(ed3).Append(ElemIndex);
  }

  return ElemIndex;
}

//=======================================================================
//function : GetElement
//purpose  : 
//=======================================================================
const Element&  MeshDS_Mesh2d::GetElement(const Standard_Integer Index)
{
  return myElements.FindKey(Index);
}

//=======================================================================
//function : RemoveElement
//purpose  : 
//=======================================================================
void  MeshDS_Mesh2d::RemoveElement(const Standard_Integer Index)
{
  //Warning, the static cast from const& to & is called for
  //performance reasons. This is applicable only in case if later
  //modification of element (field movability) does not influent on
  //has calculation.
  Element& lelem=(Element&)myElements.FindKey(Index);
  if (lelem.Movability()!=MeshDS_Deleted) {
    ClearElement(Index, lelem);
    lelem.SetMovability(MeshDS_Deleted);
    // Not_Debuged_Yet myDelElements.Append(Index);
    myElemOfDomain.Remove(Index);
  }
}

static void removeElementIndex(MeshDS_PairOfIndex& thePair,
                               const Standard_Integer Index)
{
  for(Standard_Integer i = 1, n = thePair.Extent(); i <= n; i++) {
    if (thePair.Index(i)==Index) {
      thePair.RemoveIndex(i);
      break;
    }
  }
}

void  MeshDS_Mesh2d::ClearElement(const Standard_Integer Index,
				  const Element& theElem)
{
  if (theElem.Movability()==MeshDS_Free) {
    Standard_Integer ed1, ed2, ed3;
    Standard_Boolean or1, or2, or3;
    theElem.Edges(ed1, ed2, ed3, or1, or2, or3);
    removeElementIndex(myLinks(ed1),Index);
    removeElementIndex(myLinks(ed2),Index);
    removeElementIndex(myLinks(ed3),Index);
  }
}

//=======================================================================
//function : SubstituteElement
//purpose  : 
//=======================================================================
Standard_Boolean  MeshDS_Mesh2d::SubstituteElement
  (const Standard_Integer Index, const Element& newElement)
{
  const Element& lelem=myElements.FindKey(Index);
  if (lelem.Movability()==MeshDS_Deleted) 
    myElements.Substitute(Index, newElement);
  else {
    if (myElements.FindIndex(newElement)==0) {
      ClearElement(Index, lelem);
      // Warning: here new element and old element should have different Hash code
      myElements.Substitute(Index, newElement);

      Standard_Integer ed1, ed2, ed3;
      Standard_Boolean or1, or2, or3;
      newElement.Edges(ed1, ed2, ed3, or1, or2, or3);
      myLinks(ed1).Append(Index);
      myLinks(ed2).Append(Index);
      myLinks(ed3).Append(Index);
    }
    else return Standard_False;
  }
  return Standard_True;
}

//=======================================================================
//function : ClearDomain
//purpose  : 
//=======================================================================
void MeshDS_Mesh2d::ClearDomain()
{
  MeshDS_MapOfInteger freeEdges;
  Standard_Integer ed1, ed2, ed3;
  Standard_Boolean or1, or2, or3;
  MeshDS_MapOfInteger::Iterator itDom(myElemOfDomain);
  //Warning, the static cast from const& to & is called for
  //performance reasons. This is applicable only in case if later
  //modification of element (field movability) does not influent on
  //has calculation.
  for (;itDom.More(); itDom.Next()) {
    Element& lelem=(Element&)myElements.FindKey(itDom.Key());
    lelem.Edges(ed1, ed2, ed3, or1, or2, or3);
    freeEdges.Add(ed1);
    freeEdges.Add(ed2);
    freeEdges.Add(ed3);
    ClearElement(itDom.Key(), lelem);
    lelem.SetMovability(MeshDS_Deleted);
    // Not_Debuged_Yet myDelElements.Append(itDom.Key());
  }
  myElemOfDomain.Clear();
  MeshDS_MapOfInteger::Iterator edgeIt(freeEdges);
  for (; edgeIt.More(); edgeIt.Next())
    RemoveLink(edgeIt.Key());
}

//=======================================================================
//function : NbElements
//purpose  : 
//=======================================================================
Standard_Integer  MeshDS_Mesh2d::NbElements()const 
{
  return myElements.Extent();
}

//=======================================================================
//function : IndexOf
//purpose  : 
//=======================================================================
Standard_Integer MeshDS_Mesh2d::IndexOf(const Node& aNode)const
{
  return myNodes.FindIndex(aNode);
}

//=======================================================================
//function : IndexOf
//purpose  : 
//=======================================================================
Standard_Integer MeshDS_Mesh2d::IndexOf(const Link& aLink)const
{
  return myLinks.FindIndex(aLink);
}

//=======================================================================
//function : IndexOf
//purpose  : 
//=======================================================================
Standard_Integer MeshDS_Mesh2d::IndexOf(const Element& anElement)const
{
  return myElements.FindIndex(anElement);
}

//=======================================================================
//function : LinkNeighboursOf
//purpose  : 
//=======================================================================
const MeshDS_ListOfInteger&  MeshDS_Mesh2d::LinkNeighboursOf
  (const Standard_Integer theNode)const 
{
  return myNodes.FindFromIndex(theNode);
}

//=======================================================================
//function : ElemConnectedTo
//purpose  : 
//=======================================================================
const MeshDS_PairOfIndex&  MeshDS_Mesh2d::ElemConnectedTo 
  (const Standard_Integer theLink)const 
{
  return myLinks.FindFromIndex(theLink);
}

//=======================================================================
//function : ElemOfDomain
//purpose  : 
//=======================================================================
const MeshDS_MapOfInteger&  MeshDS_Mesh2d::ElemOfDomain () const
{
  return myElemOfDomain;
}

//=======================================================================
//function : LinkOfDomain
//purpose  : 
//=======================================================================
const MeshDS_MapOfInteger&  MeshDS_Mesh2d::LinkOfDomain () const
{
  return myLinkOfDomain;
}

//=======================================================================
//function : ClearDeleted
//purpose  : 
//=======================================================================
void MeshDS_Mesh2d::ClearDeleted()
{

  // Traitement des Elements 

  Standard_Integer IndexDelItem;

  Standard_Integer lastNonDelItem=myElements.Extent();
  /* // Not_Debuged_Yet 
  while (!myDelElements.IsEmpty()) {
    while (lastNonDelItem>0) {
      if (myElements.FindKey(lastNonDelItem).Movability()!=MeshDS_Deleted)
	break;
      myElements.RemoveLast();
      lastNonDelItem--;
    }

    IndexDelItem=myDelElements.First();
    myDelElements.RemoveFirst();

    if (IndexDelItem<lastNonDelItem) {
      Element eItem=myElements.FindKey(lastNonDelItem);
      myElements.RemoveLast();
      myElements.Substitute(IndexDelItem, eItem);
      myElemOfDomain.Remove(lastNonDelItem);
      myElemOfDomain.Add(IndexDelItem);
      lastNonDelItem--;

      Standard_Integer ed[3], ied;
      Standard_Boolean orient[3];
      eItem.Edges(ed[0], ed[1], ed[2], orient[0], orient[1], orient[2]);
      MeshDS_ListOfInteger::Iterator itList;
      for (ied=0; ied<3; ied++) {
	MeshDS_PairOfIndex& aPair = myLinks(ed[ied]);
	for(Standard_Integer j = 1, jn = aPair.Extent(); j <= jn; j++)
	  if (aPair.Index(j)==(lastNonDelItem+1)) {
	    aPair.SetIndex(j,IndexDelItem);
	    break;
	  }
      }
    }
  }
  */

  // Traitement des Links 

  lastNonDelItem=myLinks.Extent();

  while (!myDelLinks.IsEmpty()) {
    while (lastNonDelItem>0) {
      if (myLinks.FindKey(lastNonDelItem).Movability()!=MeshDS_Deleted)
	break;
      myLinks.RemoveLast();
      lastNonDelItem--;
    }

    IndexDelItem=myDelLinks.First();
    myDelLinks.RemoveFirst();

    if (IndexDelItem<lastNonDelItem) {
      Link lItem=myLinks.FindKey(lastNonDelItem);
      MeshDS_PairOfIndex Data(myLinks(lastNonDelItem));
      myLinks.RemoveLast();
      myLinks.Substitute(IndexDelItem, lItem, Data);
      myLinkOfDomain.Remove(lastNonDelItem);
      myLinkOfDomain.Add(IndexDelItem);
      lastNonDelItem--;

      Standard_Integer iv[2], ivx;
      iv[0]=lItem.FirstNode();
      iv[1]=lItem.LastNode();

      MeshDS_ListOfInteger::Iterator itLis;
      for (ivx=0; ivx<2; ivx++) {
	for (itLis.Init(myNodes(iv[ivx])); 
	     itLis.More(); itLis.Next()) {
	  if (itLis.Value()==(lastNonDelItem+1)) {
	    itLis.ChangeValue()=IndexDelItem;
	    break;
	  }
	}
      }
      for(Standard_Integer j = 1, jn = Data.Extent(); j <= jn; j++) {
	const Element& Elem=myElements.FindKey(Data.Index(j));

	Standard_Integer el[3], iel;
	Standard_Boolean orl[3];
	Elem.Edges(el[0], el[1], el[2], orl[0], orl[1], orl[2]);
	for (iel=0; iel<3; iel++) {
	  if (el[iel]==lastNonDelItem+1) {
	    el[iel]=IndexDelItem;
	    break;
	  }
	}
	myElements.Substitute(itLis.Value(),
			      Element(el[0], el[1], el[2],
				      orl[0], orl[1], orl[2],
				      Elem.Movability() ));
      }
    }
  }


// Traitement des Nodes :

  lastNonDelItem=myNodes.Extent();

  while (!myDelNodes.IsEmpty()) {
    while (lastNonDelItem>0) {
      if (myNodes.FindKey(lastNonDelItem).Movability()!=MeshDS_Deleted)
	break;
      myNodes.RemoveLast();
      lastNonDelItem--;
    }
    IndexDelItem=myDelNodes.First();
    myDelNodes.RemoveFirst();

    if (IndexDelItem<lastNonDelItem) {
      Node nItem=myNodes.FindKey(lastNonDelItem);
      MeshDS_ListOfInteger Data;
      Data.Append(myNodes(lastNonDelItem));
      myNodes.RemoveLast();
      lastNonDelItem--;
      myNodes.Substitute(IndexDelItem, nItem, Data);

      MeshDS_ListOfInteger::Iterator itLi;
      for (itLi.Init(Data); itLi.More(); itLi.Next()) {
	const Link& li=myLinks.FindKey(itLi.Value());
	MeshDS_PairOfIndex conx(myLinks(itLi.Value()));
	Standard_Integer iv1=li.FirstNode();
	Standard_Integer iv2=li.LastNode();
	if      (iv1==lastNonDelItem+1) iv1=IndexDelItem;
	else if (iv2==lastNonDelItem+1) iv2=IndexDelItem;

	myLinks.Substitute(itLi.Value(),
			   Link(iv1, iv2, li.Movability()), conx);
      }
    }
  }
}

//=======================================================================
//function : Statistics
//purpose  : 
//=======================================================================
void MeshDS_Mesh2d::Statistics(Standard_OStream& S) const
{
  S << " Map de nodes : \n";
  myNodes.Statistics(S);
  S << "\n Deleted nodes : " << myDelNodes.Extent() << endl;

  S << "\n\n Map de Links : \n";
  myLinks.Statistics(S);
  S << "\n Deleted links : " << myDelLinks.Extent() << endl;

  S << "\n\n Map d elements : \n";
  myElements.Statistics(S);
  // Not_Debuged_Yet S << "\n Deleted elements : " << myDelElements.Extent() << endl;
}

//=======================================================================
//function : Allocator()
//purpose  : 
//=======================================================================
const MeshDS_BaseAllocator& MeshDS_Mesh2d::Allocator() const
{
  return myAllocator;
}
