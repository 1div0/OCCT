// This file has been automatically generated from resource file src/Shaders/PathtraceBase.fs

static const char Shaders_PathtraceBase_fs[] =
  "#ifdef PATH_TRACING\n"
  "\n"
  "///////////////////////////////////////////////////////////////////////////////////////\n"
  "// Specific data types\n"
  "\n"
  "//! Describes local space at the hit point (visualization space).\n"
  "struct SLocalSpace\n"
  "{\n"
  "  //! Local X axis.\n"
  "  vec3 AxisX;\n"
  "\n"
  "  //! Local Y axis.\n"
  "  vec3 AxisY;\n"
  "\n"
  "  //! Local Z axis.\n"
  "  vec3 AxisZ;\n"
  "};\n"
  "\n"
  "//! Describes material properties (BSDF).\n"
  "struct SMaterial\n"
  "{\n"
  "  //! Weight of the Lambertian BRDF.\n"
  "  vec4 Kd;\n"
  "\n"
  "  //! Weight of the reflection BRDF.\n"
  "  vec3 Kr;\n"
  "\n"
  "  //! Weight of the transmission BTDF.\n"
  "  vec3 Kt;\n"
  "\n"
  "  //! Weight of the Blinn BRDF (and roughness).\n"
  "  vec4 Ks;\n"
  "\n"
  "  //! Fresnel coefficients.\n"
  "  vec3 Fresnel;\n"
  "\n"
  "  //! Absorption color and intensity of the media.\n"
  "  vec4 Absorption;\n"
  "};\n"
  "\n"
  "///////////////////////////////////////////////////////////////////////////////////////\n"
  "// Support subroutines\n"
  "\n"
  "//=======================================================================\n"
  "// function : LocalSpace\n"
  "// purpose  : Generates local space for the given normal\n"
  "//=======================================================================\n"
  "SLocalSpace LocalSpace (in vec3 theNormal)\n"
  "{\n"
  "  vec3 anAxisX = cross (vec3 (0.f, 1.f, 0.f), theNormal);\n"
  "  vec3 anAxisY = cross (vec3 (1.f, 0.f, 0.f), theNormal);\n"
  "\n"
  "  float aSqrLenX = dot (anAxisX, anAxisX);\n"
  "  float aSqrLenY = dot (anAxisY, anAxisY);\n"
  "\n"
  "  if (aSqrLenX > aSqrLenY)\n"
  "  {\n"
  "    anAxisX *= inversesqrt (aSqrLenX);\n"
  "    anAxisY = cross (anAxisX, theNormal);\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    anAxisY *= inversesqrt (aSqrLenY);\n"
  "    anAxisX = cross (anAxisY, theNormal);\n"
  "  }\n"
  "\n"
  "  return SLocalSpace (anAxisX, anAxisY, theNormal);\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : toLocalSpace\n"
  "// purpose  : Transforms the vector to local space from world space\n"
  "//=======================================================================\n"
  "vec3 toLocalSpace (in vec3 theVector, in SLocalSpace theSpace)\n"
  "{\n"
  "  return vec3 (dot (theVector, theSpace.AxisX),\n"
  "               dot (theVector, theSpace.AxisY),\n"
  "               dot (theVector, theSpace.AxisZ));\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : fromLocalSpace\n"
  "// purpose  : Transforms the vector from local space to world space\n"
  "//=======================================================================\n"
  "vec3 fromLocalSpace (in vec3 theVector, in SLocalSpace theSpace)\n"
  "{\n"
  "  return theVector.x * theSpace.AxisX +\n"
  "         theVector.y * theSpace.AxisY +\n"
  "         theVector.z * theSpace.AxisZ;\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : convolve\n"
  "// purpose  : Performs a linear convolution of the vector components\n"
  "//=======================================================================\n"
  "float convolve (in vec3 theVector, in vec3 theFactor)\n"
  "{\n"
  "  return dot (theVector, theFactor) * (1.f / max (theFactor.x + theFactor.y + theFactor.z, 1e-15f));\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : sphericalDirection\n"
  "// purpose  : Constructs vector from spherical coordinates\n"
  "//=======================================================================\n"
  "vec3 sphericalDirection (in float theCosTheta, in float thePhi)\n"
  "{\n"
  "  float aSinTheta = sqrt (1.f - theCosTheta * theCosTheta);\n"
  "\n"
  "  return vec3 (aSinTheta * cos (thePhi),\n"
  "               aSinTheta * sin (thePhi),\n"
  "               theCosTheta);\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : fresnelSchlick\n"
  "// purpose  : Computes the Fresnel reflection formula using\n"
  "//            Schlick's approximation.\n"
  "//=======================================================================\n"
  "vec3 fresnelSchlick (in float theCosI, in vec3 theSpecularColor)\n"
  "{\n"
  "  return theSpecularColor + (UNIT - theSpecularColor) * pow (1.f - theCosI, 5.f);\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : fresnelDielectric\n"
  "// purpose  : Computes the Fresnel reflection formula for dielectric in\n"
  "//            case of circularly polarized light (Based on PBRT code).\n"
  "//=======================================================================\n"
  "float fresnelDielectric (in float theCosI,\n"
  "                         in float theCosT,\n"
  "                         in float theEtaI,\n"
  "                         in float theEtaT)\n"
  "{\n"
  "  float aParl = (theEtaT * theCosI - theEtaI * theCosT) /\n"
  "                (theEtaT * theCosI + theEtaI * theCosT);\n"
  "\n"
  "  float aPerp = (theEtaI * theCosI - theEtaT * theCosT) /\n"
  "                (theEtaI * theCosI + theEtaT * theCosT);\n"
  "\n"
  "  return (aParl * aParl + aPerp * aPerp) * 0.5f;\n"
  "}\n"
  "\n"
  "#define ENVIRONMENT_IOR 1.f\n"
  "\n"
  "//=======================================================================\n"
  "// function : fresnelDielectric\n"
  "// purpose  : Computes the Fresnel reflection formula for dielectric in\n"
  "//            case of circularly polarized light (based on PBRT code)\n"
  "//=======================================================================\n"
  "float fresnelDielectric (in float theCosI, in float theIndex)\n"
  "{\n"
  "  float anEtaI = theCosI > 0.f ? 1.f : theIndex;\n"
  "  float anEtaT = theCosI > 0.f ? theIndex : 1.f;\n"
  "\n"
  "  float aSinT = (anEtaI / anEtaT) * sqrt (1.f - theCosI * theCosI);\n"
  "\n"
  "  if (aSinT >= 1.f)\n"
  "  {\n"
  "    return 1.f;\n"
  "  }\n"
  "\n"
  "  float aCosT = sqrt (1.f - aSinT * aSinT);\n"
  "\n"
  "  return fresnelDielectric (abs (theCosI), aCosT, anEtaI, anEtaT);\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : fresnelConductor\n"
  "// purpose  : Computes the Fresnel reflection formula for conductor in case\n"
  "//            of circularly polarized light (based on PBRT source code)\n"
  "//=======================================================================\n"
  "float fresnelConductor (in float theCosI, in float theEta, in float theK)\n"
  "{\n"
  "  float aTmp = 2.f * theEta * theCosI;\n"
  "\n"
  "  float aTmp1 = theEta * theEta + theK * theK;\n"
  "\n"
  "  float aSPerp = (aTmp1 - aTmp + theCosI * theCosI) /\n"
  "                 (aTmp1 + aTmp + theCosI * theCosI);\n"
  "\n"
  "  float aTmp2 = aTmp1 * theCosI * theCosI;\n"
  "\n"
  "  float aSParl = (aTmp2 - aTmp + 1.f) /\n"
  "                 (aTmp2 + aTmp + 1.f);\n"
  "\n"
  "  return (aSPerp + aSParl) * 0.5f;\n"
  "}\n"
  "\n"
  "#define FRESNEL_SCHLICK    -0.5f\n"
  "#define FRESNEL_CONSTANT   -1.5f\n"
  "#define FRESNEL_CONDUCTOR  -2.5f\n"
  "#define FRESNEL_DIELECTRIC -3.5f\n"
  "\n"
  "//=======================================================================\n"
  "// function : fresnelMedia\n"
  "// purpose  : Computes the Fresnel reflection formula for general medium\n"
  "//            in case of circularly polarized light.\n"
  "//=======================================================================\n"
  "vec3 fresnelMedia (in float theCosI, in vec3 theFresnelCoeffs)\n"
  "{\n"
  "  if (theFresnelCoeffs.x > FRESNEL_SCHLICK)\n"
  "  {\n"
  "    return fresnelSchlick (abs (theCosI), theFresnelCoeffs);\n"
  "  }\n"
  "\n"
  "  if (theFresnelCoeffs.x > FRESNEL_CONSTANT)\n"
  "  {\n"
  "    return vec3 (theFresnelCoeffs.z);\n"
  "  }\n"
  "\n"
  "  if (theFresnelCoeffs.x > FRESNEL_CONDUCTOR)\n"
  "  {\n"
  "    return vec3 (fresnelConductor (abs (theCosI), theFresnelCoeffs.y, theFresnelCoeffs.z));\n"
  "  }\n"
  "\n"
  "  return vec3 (fresnelDielectric (theCosI, theFresnelCoeffs.y));\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : transmitted\n"
  "// purpose  : Computes transmitted direction in tangent space\n"
  "//            (in case of TIR returned result is undefined!)\n"
  "//=======================================================================\n"
  "void transmitted (in float theIndex, in vec3 theIncident, out vec3 theTransmit)\n"
  "{\n"
  "  // Compute relative index of refraction\n"
  "  float anEta = (theIncident.z > 0.f) ? 1.f / theIndex : theIndex;\n"
  "\n"
  "  // Handle total internal reflection for transmission\n"
  "  float aSinT2 = anEta * anEta * (1.f - theIncident.z * theIncident.z);\n"
  "\n"
  "  // Compute transmitted ray direction\n"
  "  float aCosT = sqrt (1.f - min (aSinT2, 1.f)) * (theIncident.z > 0.f ? -1.f : 1.f);\n"
  "\n"
  "  theTransmit = normalize (vec3 (-anEta * theIncident.x,\n"
  "                                 -anEta * theIncident.y,\n"
  "                                  aCosT));\n"
  "}\n"
  "\n"
  "//////////////////////////////////////////////////////////////////////////////////////////////\n"
  "// Handlers and samplers for materials\n"
  "//////////////////////////////////////////////////////////////////////////////////////////////\n"
  "\n"
  "//=======================================================================\n"
  "// function : handleLambertianReflection\n"
  "// purpose  : Handles Lambertian BRDF, with cos(N, PSI)\n"
  "//=======================================================================\n"
  "float handleLambertianReflection (in vec3 theInput, in vec3 theOutput)\n"
  "{\n"
  "  return max (0.f, theInput.z) * (1.f / M_PI);\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : handleBlinnReflection\n"
  "// purpose  : Handles Blinn glossy BRDF, with cos(N, PSI)\n"
  "//=======================================================================\n"
  "vec3 handleBlinnReflection (in vec3 theInput, in vec3 theOutput, in vec3 theFresnelCoeffs, in float theExponent)\n"
  "{\n"
  "  vec3 aWeight = ZERO;\n"
  "\n"
  "  // Compute half-angle vector\n"
  "  vec3 aHalf = theInput + theOutput;\n"
  "\n"
  "  if (aHalf.z < 0.f)\n"
  "    aHalf = -aHalf;\n"
  "\n"
  "  float aLength = dot (aHalf, aHalf);\n"
  "\n"
  "  if (aLength <= 0.f)\n"
  "    return ZERO;\n"
  "\n"
  "  aHalf *= inversesqrt (aLength);\n"
  "\n"
  "  // Compute Fresnel reflectance\n"
  "  float aCosDelta = dot (theOutput, aHalf);\n"
  "\n"
  "  vec3 aFresnel = fresnelMedia (aCosDelta, theFresnelCoeffs);\n"
  "\n"
  "  // Compute fraction of microfacets that reflect light\n"
  "  float aCosThetaH = max (0.f, aHalf.z);\n"
  "\n"
  "  float aFraction = (theExponent + 2.f) * (M_PI / 2.f) * pow (aCosThetaH, theExponent);\n"
  "\n"
  "  // Compute geometry attenuation term (already includes cos)\n"
  "  float aCosThetaI = max (0.f, theInput.z);\n"
  "  float aCosThetaO = max (0.f, theOutput.z);\n"
  "\n"
  "  float aGeom = min (1.f, 2.f * aCosThetaH / max (0.f, aCosDelta) * min (aCosThetaO, aCosThetaI));\n"
  "\n"
  "  return aCosThetaO < 1.0e-3f ? ZERO :\n"
  "    aFraction * aGeom / (4.f * aCosThetaO) * aFresnel;\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : handleMaterial\n"
  "// purpose  : Returns BSDF value for specified material, with cos(N, PSI)\n"
  "//=======================================================================\n"
  "vec3 handleMaterial (in SMaterial theMaterial, in vec3 theInput, in vec3 theOutput)\n"
  "{\n"
  "  return theMaterial.Kd.rgb * handleLambertianReflection (theInput, theOutput) +\n"
  "    theMaterial.Ks.rgb * handleBlinnReflection (theInput, theOutput, theMaterial.Fresnel, theMaterial.Ks.w);\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : sampleLambertianReflection\n"
  "// purpose  : Samples Lambertian BRDF, W = BRDF * cos(N, PSI) / PDF(PSI)\n"
  "//=======================================================================\n"
  "void sampleLambertianReflection (in vec3 theOutput, out vec3 theInput)\n"
  "{\n"
  "  float aKsi1 = RandFloat();\n"
  "  float aKsi2 = RandFloat();\n"
  "\n"
  "  float aTemp = sqrt (aKsi2);\n"
  "\n"
  "  theInput = vec3 (aTemp * cos (2.f * M_PI * aKsi1),\n"
  "                   aTemp * sin (2.f * M_PI * aKsi1),\n"
  "                   sqrt (1.f - aKsi2));\n"
  "\n"
  "  theInput.z = mix (-theInput.z, theInput.z, step (0.f, theOutput.z));\n"
  "}\n"
  "\n"
  "// Types of bounces\n"
  "#define NON_SPECULAR_BOUNCE 0\n"
  "#define SPEC_REFLECT_BOUNCE 1\n"
  "#define SPEC_REFRACT_BOUNCE 2\n"
  "\n"
  "#define IS_NON_SPEC_BOUNCE(theBounce) (theBounce == 0)\n"
  "#define IS_ANY_SPEC_BOUNCE(theBounce) (theBounce != 0)\n"
  "#define IS_REFL_SPEC_BOUNCE(theBounce) (theBounce == 1)\n"
  "#define IS_REFR_SPEC_BOUNCE(theBounce) (theBounce == 2)\n"
  "\n"
  "//=======================================================================\n"
  "// function : sampleSpecularTransmission\n"
  "// purpose  : Samples specular BTDF, W = BRDF * cos(N, PSI) / PDF(PSI)\n"
  "//=======================================================================\n"
  "vec3 sampleSpecularTransmission (in vec3 theOutput, out vec3 theInput,\n"
  "  out int theBounce, in vec3 theWeight, in vec3 theFresnelCoeffs)\n"
  "{\n"
  "  vec3 aFresnel = fresnelMedia (theOutput.z, theFresnelCoeffs);\n"
  "\n"
  "  float aProbability = convolve (aFresnel, theWeight);\n"
  "\n"
  "  // Check if transmission takes place\n"
  "  theBounce = RandFloat() <= aProbability ?\n"
  "    SPEC_REFLECT_BOUNCE : SPEC_REFRACT_BOUNCE;\n"
  "\n"
  "  // Sample input direction\n"
  "  if (theBounce == SPEC_REFLECT_BOUNCE)\n"
  "  {\n"
  "    theInput = vec3 (-theOutput.x,\n"
  "                     -theOutput.y,\n"
  "                      theOutput.z);\n"
  "\n"
  "    theWeight = aFresnel * (1.f / aProbability);\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    transmitted (theFresnelCoeffs.y, theOutput, theInput);\n"
  "\n"
  "    theWeight = (UNIT - aFresnel) * (1.f / (1.f - aProbability));\n"
  "  }\n"
  "\n"
  "  return theWeight;\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : sampleSpecularReflection\n"
  "// purpose  : Samples specular BRDF, W = BRDF * cos(N, PSI) / PDF(PSI)\n"
  "//=======================================================================\n"
  "vec3 sampleSpecularReflection (in vec3 theOutput, out vec3 theInput, in vec3 theFresnelCoeffs)\n"
  "{\n"
  "  // Sample input direction\n"
  "  theInput = vec3 (-theOutput.x,\n"
  "                   -theOutput.y,\n"
  "                    theOutput.z);\n"
  "\n"
  "  return fresnelMedia (theOutput.z, theFresnelCoeffs);\n"
  "}\n"
  "\n"
  "#define MIN_COS 1.0e-20f\n"
  "\n"
  "//=======================================================================\n"
  "// function : sampleBlinnReflection\n"
  "// purpose  : Samples Blinn BRDF, W = BRDF * cos(N, PSI) / PDF(PSI)\n"
  "//            The BRDF is a product of three main terms, D, G, and F,\n"
  "//            which is then divided by two cosine terms. Here we perform\n"
  "//            importance sample the D part of the Blinn model; trying to\n"
  "//            develop a sampling procedure that accounted for all of the\n"
  "//            terms would be complex, and it is the D term that accounts\n"
  "//            for most of the variation.\n"
  "//=======================================================================\n"
  "vec3 sampleBlinnReflection (in vec3 theOutput, out vec3 theInput, in vec3 theFresnelCoeffs, in float theExponent)\n"
  "{\n"
  "  vec3 aWeight = ZERO;\n"
  "\n"
  "  // Generate two random variables\n"
  "  float aKsi1 = RandFloat();\n"
  "  float aKsi2 = RandFloat();\n"
  "\n"
  "  // Compute sampled half-angle vector for Blinn distribution\n"
  "  float aCosThetaH = pow (aKsi1, 1.f / (theExponent + 1.f));\n"
  "\n"
  "  vec3 aHalf = sphericalDirection (aCosThetaH, aKsi2 * 2.f * M_PI);\n"
  "\n"
  "  if (aHalf.z < 0)\n"
  "  {\n"
  "    aHalf = -aHalf;\n"
  "  }\n"
  "\n"
  "  // Compute incident direction by reflecting about half-vector\n"
  "  float aCosDelta = dot (theOutput, aHalf);\n"
  "\n"
  "  vec3 anInput = 2.f * aCosDelta * aHalf - theOutput;\n"
  "\n"
  "  if (theOutput.z * anInput.z <= 0.f)\n"
  "  {\n"
  "    return ZERO;\n"
  "  }\n"
  "\n"
  "  theInput = anInput;\n"
  "\n"
  "  // Compute Fresnel reflectance\n"
  "  vec3 aFresnel = fresnelMedia (aCosDelta, theFresnelCoeffs);\n"
  "\n"
  "  // Compute geometry attenuation term\n"
  "  float aCosThetaI = max (MIN_COS, theInput.z);\n"
  "  float aCosThetaO = max (MIN_COS, theOutput.z);\n"
  "\n"
  "  float aGeom = min (max (MIN_COS, aCosDelta), 2.f * aCosThetaH * min (aCosThetaO, aCosThetaI));\n"
  "\n"
  "  // Compute weight of the ray sample\n"
  "  return aFresnel * ((theExponent + 2.f) / (theExponent + 1.f) * aGeom / aCosThetaO);\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : sampleMaterial\n"
  "// purpose  : Samples specified composite material (BSDF)\n"
  "//=======================================================================\n"
  "void sampleMaterial (in SMaterial theMaterial,\n"
  "                     in vec3      theOutput,\n"
  "                     out vec3     theInput,\n"
  "                     inout vec3   theWeight,\n"
  "                     inout int    theBounce)\n"
  "{\n"
  "  // Compute the probability of ray reflection\n"
  "  float aPd = convolve (theMaterial.Kd.rgb, theWeight);\n"
  "  float aPs = convolve (theMaterial.Ks.rgb, theWeight);\n"
  "  float aPr = convolve (theMaterial.Kr.rgb, theWeight);\n"
  "  float aPt = convolve (theMaterial.Kt.rgb, theWeight);\n"
  "\n"
  "  float aReflection = aPd + aPs + aPr + aPt;\n"
  "\n"
  "  // Choose BSDF component to sample\n"
  "  float aKsi = aReflection * RandFloat();\n"
  "\n"
  "  theBounce = NON_SPECULAR_BOUNCE;\n"
  "\n"
  "  if (aKsi < aPd) // diffuse reflection\n"
  "  {\n"
  "    sampleLambertianReflection (theOutput, theInput);\n"
  "\n"
  "    theWeight *= theMaterial.Kd.rgb * (aReflection / aPd);\n"
  "  }\n"
  "  else if (aKsi < aPd + aPs) //  glossy reflection\n"
  "  {\n"
  "    theWeight *= theMaterial.Ks.rgb * (aReflection / aPs) *\n"
  "      sampleBlinnReflection (theOutput, theInput, theMaterial.Fresnel, theMaterial.Ks.w);\n"
  "  }\n"
  "  else if (aKsi < aPd + aPs + aPr) //  specular reflection\n"
  "  {\n"
  "    theWeight *= theMaterial.Kr.rgb * (aReflection / aPr) *\n"
  "      sampleSpecularReflection (theOutput, theInput, theMaterial.Fresnel);\n"
  "\n"
  "    theBounce = SPEC_REFLECT_BOUNCE; // specular bounce\n"
  "  }\n"
  "  else //  specular transmission\n"
  "  {\n"
  "    theWeight *= theMaterial.Kt.rgb * (aReflection / aPt) *\n"
  "      sampleSpecularTransmission (theOutput, theInput, theBounce, theWeight, theMaterial.Fresnel);\n"
  "  }\n"
  "\n"
  "  // path termination for extra small weights\n"
  "  theWeight = mix (theWeight, ZERO, float (aReflection < 1e-3f));\n"
  "}\n"
  "\n"
  "//////////////////////////////////////////////////////////////////////////////////////////////\n"
  "// Handlers and samplers for light sources\n"
  "//////////////////////////////////////////////////////////////////////////////////////////////\n"
  "\n"
  "//=======================================================================\n"
  "// function : handlePointLight\n"
  "// purpose  :\n"
  "//=======================================================================\n"
  "float handlePointLight (in vec3 theInput, in vec3 theToLight, in float theRadius, in float theDistance)\n"
  "{\n"
  "  float aDistance = dot (theToLight, theToLight);\n"
  "\n"
  "  float aCosMax = inversesqrt (1.f + theRadius * theRadius / aDistance);\n"
  "\n"
  "  return float (aDistance < theDistance * theDistance) *\n"
  "    step (aCosMax, dot (theToLight, theInput) * inversesqrt (aDistance));\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : handleDirectLight\n"
  "// purpose  :\n"
  "//=======================================================================\n"
  "float handleDirectLight (in vec3 theInput, in vec3 theToLight, in float theCosMax)\n"
  "{\n"
  "  return step (theCosMax, dot (theInput, theToLight));\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : sampleLight\n"
  "// purpose  : General sampling function for directional and point lights\n"
  "//=======================================================================\n"
  "vec3 sampleLight (in vec3 theToLight, inout float theDistance, in bool isInfinite, in float theSmoothness, inout float thePDF)\n"
  "{\n"
  "  SLocalSpace aSpace = LocalSpace (theToLight * (1.f / theDistance));\n"
  "\n"
  "  // for point lights smoothness defines radius\n"
  "  float aCosMax = isInfinite ? theSmoothness :\n"
  "    inversesqrt (1.f + theSmoothness * theSmoothness / (theDistance * theDistance));\n"
  "\n"
  "  float aKsi1 = RandFloat();\n"
  "  float aKsi2 = RandFloat();\n"
  "\n"
  "  float aTmp = 1.f - aKsi2 * (1.f - aCosMax);\n"
  "\n"
  "  vec3 anInput = vec3 (cos (2.f * M_PI * aKsi1),\n"
  "                       sin (2.f * M_PI * aKsi1),\n"
  "                       aTmp);\n"
  "\n"
  "  anInput.xy *= sqrt (1.f - aTmp * aTmp);\n"
  "\n"
  "  thePDF *= (aCosMax < 1.f) ? 1.f / (2.f * M_PI) / (1.f - aCosMax) : 1.f;\n"
  "\n"
  "  return normalize (fromLocalSpace (anInput, aSpace));\n"
  "}\n"
  "\n"
  "// =======================================================================\n"
  "// function : Latlong\n"
  "// purpose  : Converts world direction to environment texture coordinates\n"
  "// =======================================================================\n"
  "vec2 Latlong (in vec3 thePoint)\n"
  "{\n"
  "  float aPsi = acos (-thePoint.z);\n"
  "\n"
  "  float aPhi = atan (thePoint.y, thePoint.x) + M_PI;\n"
  "\n"
  "  return vec2 (aPhi * 0.1591549f,\n"
  "               aPsi * 0.3183098f);\n"
  "}\n"
  "\n"
  "// =======================================================================\n"
  "// function: intersectLight\n"
  "// purpose : Checks intersections with light sources\n"
  "// =======================================================================\n"
  "vec3 intersectLight (in SRay theRay, in bool isViewRay, in int theBounce, in float theDistance)\n"
  "{\n"
  "  vec3 aRadiance = ZERO;\n"
  "\n"
  "  if ((isViewRay || IS_REFR_SPEC_BOUNCE(theBounce)) && uSphereMapForBack == 0)\n"
  "  {\n"
  "    aRadiance = BackgroundColor().xyz;\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    aRadiance = FetchEnvironment (Latlong (theRay.Direct)).xyz;\n"
  "  }\n"
  "\n"
  "  // Apply gamma correction (gamma is 2)\n"
  "  aRadiance = aRadiance * aRadiance * float (theDistance == MAXFLOAT);\n"
  "\n"
  "  for (int aLightIdx = 0; aLightIdx < uLightCount && (isViewRay || IS_ANY_SPEC_BOUNCE(theBounce)); ++aLightIdx)\n"
  "  {\n"
  "    vec4 aLight = texelFetch (\n"
  "      uRaytraceLightSrcTexture, LIGHT_POS (aLightIdx));\n"
  "    vec4 aParam = texelFetch (\n"
  "      uRaytraceLightSrcTexture, LIGHT_PWR (aLightIdx));\n"
  "\n"
  "    if (aLight.w != 0.f) // point light source\n"
  "    {\n"
  "      aRadiance += aParam.rgb * handlePointLight (\n"
  "        theRay.Direct, aLight.xyz - theRay.Origin, aParam.w /* radius */, theDistance);\n"
  "    }\n"
  "    else if (theDistance == MAXFLOAT) // directional light source\n"
  "    {\n"
  "      aRadiance += aParam.rgb * handleDirectLight (theRay.Direct, aLight.xyz, aParam.w /* angle cosine */);\n"
  "    }\n"
  "  }\n"
  "\n"
  "  return aRadiance;\n"
  "}\n"
  "\n"
  "#define MIN_THROUGHPUT   vec3 (0.02f)\n"
  "#define MIN_CONTRIBUTION vec3 (0.01f)\n"
  "\n"
  "#define MATERIAL_KD(index)      (18 * index + 11)\n"
  "#define MATERIAL_KR(index)      (18 * index + 12)\n"
  "#define MATERIAL_KT(index)      (18 * index + 13)\n"
  "#define MATERIAL_KS(index)      (18 * index + 14)\n"
  "#define MATERIAL_LE(index)      (18 * index + 15)\n"
  "#define MATERIAL_FRESNEL(index) (18 * index + 16)\n"
  "#define MATERIAL_ABSORPT(index) (18 * index + 17)\n"
  "\n"
  "// Enables expiremental russian roulette sampling\n"
  "#define RUSSIAN_ROULETTE\n"
  "\n"
  "//=======================================================================\n"
  "// function : PathTrace\n"
  "// purpose  : Calculates radiance along the given ray\n"
  "//=======================================================================\n"
  "vec4 PathTrace (in SRay theRay, in vec3 theInverse)\n"
  "{\n"
  "  float aRaytraceDepth = MAXFLOAT;\n"
  "\n"
  "  vec3 aRadiance   = ZERO;\n"
  "  vec3 aThroughput = UNIT;\n"
  "\n"
  "  int aBounce = 0; // type of previous hit point\n"
  "  int aTrsfId = 0; // offset of object transform\n"
  "\n"
  "  bool isInMedium = false;\n"
  "\n"
  "  for (int aDepth = 0; aDepth < NB_BOUNCES; ++aDepth)\n"
  "  {\n"
  "    SIntersect aHit = SIntersect (MAXFLOAT, vec2 (ZERO), ZERO);\n"
  "\n"
  "    ivec4 aTriIndex = SceneNearestHit (theRay, theInverse, aHit, aTrsfId);\n"
  "\n"
  "    // check implicit path\n"
  "    vec3 aLe = intersectLight (theRay,\n"
  "      aDepth == 0 /* is view ray */, aBounce, aHit.Time);\n"
  "\n"
  "    if (any (greaterThan (aLe, ZERO)) || aTriIndex.x == -1)\n"
  "    {\n"
  "      aRadiance += aThroughput * aLe; break; // terminate path\n"
  "    }\n"
  "\n"
  "    vec3 aInvTransf0 = texelFetch (uSceneTransformTexture, aTrsfId + 0).xyz;\n"
  "    vec3 aInvTransf1 = texelFetch (uSceneTransformTexture, aTrsfId + 1).xyz;\n"
  "    vec3 aInvTransf2 = texelFetch (uSceneTransformTexture, aTrsfId + 2).xyz;\n"
  "\n"
  "    // compute geometrical normal\n"
  "    aHit.Normal = normalize (vec3 (dot (aInvTransf0, aHit.Normal),\n"
  "                                   dot (aInvTransf1, aHit.Normal),\n"
  "                                   dot (aInvTransf2, aHit.Normal)));\n"
  "\n"
  "    theRay.Origin += theRay.Direct * aHit.Time; // get new intersection point\n"
  "\n"
  "    // Evaluate depth on first hit\n"
  "    if (aDepth == 0)\n"
  "    {\n"
  "      vec4 aNDCPoint = uViewMat * vec4 (theRay.Origin, 1.f);\n"
  "\n"
  "      float aPolygonOffset = PolygonOffset (aHit.Normal, theRay.Origin);\n"
  "      aRaytraceDepth = (aNDCPoint.z / aNDCPoint.w + aPolygonOffset * POLYGON_OFFSET_SCALE) * 0.5f + 0.5f;\n"
  "    }\n"
  "\n"
  "    // fetch material (BSDF)\n"
  "    SMaterial aMaterial = SMaterial (\n"
  "      vec4 (texelFetch (uRaytraceMaterialTexture, MATERIAL_KD      (aTriIndex.w))),\n"
  "      vec3 (texelFetch (uRaytraceMaterialTexture, MATERIAL_KR      (aTriIndex.w))),\n"
  "      vec3 (texelFetch (uRaytraceMaterialTexture, MATERIAL_KT      (aTriIndex.w))),\n"
  "      vec4 (texelFetch (uRaytraceMaterialTexture, MATERIAL_KS      (aTriIndex.w))),\n"
  "      vec3 (texelFetch (uRaytraceMaterialTexture, MATERIAL_FRESNEL (aTriIndex.w))),\n"
  "      vec4 (texelFetch (uRaytraceMaterialTexture, MATERIAL_ABSORPT (aTriIndex.w))));\n"
  "\n"
  "#ifdef USE_TEXTURES\n"
  "    if (aMaterial.Kd.w >= 0.f)\n"
  "    {\n"
  "      vec4 aTexCoord = vec4 (SmoothUV (aHit.UV, aTriIndex), 0.f, 1.f);\n"
  "\n"
  "      vec4 aTrsfRow1 = texelFetch (\n"
  "        uRaytraceMaterialTexture, MATERIAL_TRS1 (aTriIndex.w));\n"
  "      vec4 aTrsfRow2 = texelFetch (\n"
  "        uRaytraceMaterialTexture, MATERIAL_TRS2 (aTriIndex.w));\n"
  "\n"
  "      aTexCoord.st = vec2 (dot (aTrsfRow1, aTexCoord),\n"
  "                           dot (aTrsfRow2, aTexCoord));\n"
  "\n"
  "      vec3 aTexColor = textureLod (\n"
  "        sampler2D (uTextureSamplers[int (aMaterial.Kd.w)]), aTexCoord.st, 0.f).rgb;\n"
  "\n"
  "      aMaterial.Kd.rgb *= aTexColor * aTexColor; // de-gamma correction (for gamma = 2)\n"
  "    }\n"
  "#endif\n"
  "\n"
  "    // compute smooth normal\n"
  "    vec3 aNormal = SmoothNormal (aHit.UV, aTriIndex);\n"
  "\n"
  "    aNormal = normalize (vec3 (dot (aInvTransf0, aNormal),\n"
  "                               dot (aInvTransf1, aNormal),\n"
  "                               dot (aInvTransf2, aNormal)));\n"
  "\n"
  "    SLocalSpace aSpace = LocalSpace (aNormal);\n"
  "\n"
  "    // account for self-emission (not stored in the material)\n"
  "    aRadiance += aThroughput * texelFetch (\n"
  "      uRaytraceMaterialTexture, MATERIAL_LE (aTriIndex.w)).rgb;\n"
  "\n"
  "    if (uLightCount > 0 && convolve (aMaterial.Kd.rgb + aMaterial.Ks.rgb, aThroughput) > 0.f)\n"
  "    {\n"
  "      int aLightIdx = min (int (floor (RandFloat() * uLightCount)), uLightCount - 1);\n"
  "\n"
  "      vec4 aLight = texelFetch (\n"
  "        uRaytraceLightSrcTexture, LIGHT_POS (aLightIdx));\n"
  "      vec4 aParam = texelFetch (\n"
  "        uRaytraceLightSrcTexture, LIGHT_PWR (aLightIdx));\n"
  "\n"
  "      // 'w' component is 0 for infinite light and 1 for point light\n"
  "      aLight.xyz -= mix (ZERO, theRay.Origin, aLight.w);\n"
  "\n"
  "      float aPDF = 1.f / uLightCount, aDistance = length (aLight.xyz);\n"
  "\n"
  "      aLight.xyz = sampleLight (aLight.xyz, aDistance,\n"
  "        aLight.w == 0.f /* is infinite */, aParam.w /* max cos or radius */, aPDF);\n"
  "\n"
  "      vec3 aContrib = (1.f / aPDF) * aParam.rgb /* Le */ * handleMaterial (\n"
  "          aMaterial, toLocalSpace (aLight.xyz, aSpace), toLocalSpace (-theRay.Direct, aSpace));\n"
  "\n"
  "      if (any (greaterThan (aContrib, MIN_CONTRIBUTION))) // first check if light source is important\n"
  "      {\n"
  "        SRay aShadow = SRay (theRay.Origin + aLight.xyz * uSceneEpsilon, aLight.xyz);\n"
  "\n"
  "        aShadow.Origin += aHit.Normal * mix (\n"
  "          -uSceneEpsilon, uSceneEpsilon, step (0.f, dot (aHit.Normal, aLight.xyz)));\n"
  "\n"
  "        float aVisibility = SceneAnyHit (aShadow,\n"
  "          InverseDirection (aLight.xyz), aLight.w == 0.f ? MAXFLOAT : aDistance);\n"
  "\n"
  "        aRadiance += aVisibility * aThroughput * aContrib;\n"
  "      }\n"
  "    }\n"
  "\n"
  "    vec3 anInput;\n"
  "\n"
  "    sampleMaterial (aMaterial,\n"
  "      toLocalSpace (-theRay.Direct, aSpace), anInput, aThroughput, aBounce);\n"
  "\n"
  "    if (isInMedium)\n"
  "    {\n"
  "      aThroughput *= exp (-aHit.Time *\n"
  "        aMaterial.Absorption.w * (UNIT - aMaterial.Absorption.rgb));\n"
  "    }\n"
  "\n"
  "    isInMedium = IS_REFR_SPEC_BOUNCE(aBounce) ? !isInMedium : isInMedium;\n"
  "\n"
  "#ifndef RUSSIAN_ROULETTE\n"
  "    if (all (lessThan (aThroughput, MIN_THROUGHPUT)))\n"
  "    {\n"
  "      aDepth = INVALID_BOUNCES; // terminate path\n"
  "    }\n"
  "#else\n"
  "    float aSurvive = aDepth < 3 ? 1.f : min (dot (LUMA, aThroughput), 0.95f);\n"
  "\n"
  "    if (RandFloat() > aSurvive)\n"
  "    {\n"
  "      aDepth = INVALID_BOUNCES; // terminate path\n"
  "    }\n"
  "\n"
  "    aThroughput /= aSurvive;\n"
  "#endif\n"
  "\n"
  "    anInput = normalize (fromLocalSpace (anInput, aSpace));\n"
  "\n"
  "    theRay = SRay (theRay.Origin + anInput * uSceneEpsilon +\n"
  "      aHit.Normal * mix (-uSceneEpsilon, uSceneEpsilon, step (0.f, dot (aHit.Normal, anInput))), anInput);\n"
  "\n"
  "    theInverse = InverseDirection (anInput);\n"
  "  }\n"
  "\n"
  "  gl_FragDepth = aRaytraceDepth;\n"
  "\n"
  "  return vec4 (aRadiance, aRaytraceDepth);\n"
  "}\n"
  "\n"
  "#endif\n";
