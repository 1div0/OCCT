// Copyright (c) 1995-1999 Matra Datavision
// Copyright (c) 1999-2012 OPEN CASCADE SAS
//
// The content of this file is subject to the Open CASCADE Technology Public
// License Version 6.5 (the "License"). You may not use the content of this file
// except in compliance with the License. Please obtain a copy of the License
// at http://www.opencascade.org and read it completely before using this file.
//
// The Initial Developer of the Original Code is Open CASCADE S.A.S., having its
// main offices at: 1, place des Freres Montgolfier, 78280 Guyancourt, France.
//
// The Original Code and all software distributed under the License is
// distributed on an "AS IS" basis, without warranty of any kind, and the
// Initial Developer hereby disclaims all such warranties, including without
// limitation, any warranties of merchantability, fitness for a particular
// purpose or non-infringement. Please see the License for the specific terms
// and conditions governing the rights and limitations under the License.

#ifdef CHRONO
#include <OSD_Chronometer.hxx>
OSD_Chronometer Chronrsnld;

#endif

#include <NCollection_IncAllocator.hxx>
#include <Precision.hxx>

IntWalk_IWalking::IntWalk_IWalking (const Standard_Real Epsilon,
                                    const Standard_Real Deflection,
                                    const Standard_Real Increment ) :
      done(Standard_False),
      fleche(Deflection),
      pas(Increment),
      tolerance(1,2),
      epsilon(Epsilon*Epsilon),
      wd1 (IntWalk_VectorOfWalkingData::allocator_type (new NCollection_IncAllocator)),
      wd2 (wd1.get_allocator()),
      nbMultiplicities (wd1.get_allocator()),
      NbPointsConfondusConsecutifs(0),
      EpsilonSembleTropGrand(0)
{
}

    
//=======================================================================
//function : Reset
//purpose  : Clears NCollection_Vector-based containers and adds
//           dummy data to maintain start index of 1 and consistent with
//           previous TCollection_Sequence-based implementation and other
//           used TCollection-based containers
//=======================================================================

void IntWalk_IWalking::Clear()
{
  wd1.clear();
  wd2.clear();
  IntWalk_WalkingData aDummy;
  aDummy.etat = -10;
  aDummy.ustart = aDummy.vstart = 0.;
  wd1.push_back (aDummy);
  wd2.push_back (aDummy);
  nbMultiplicities.clear();
  nbMultiplicities.push_back (-1);
  
  done = Standard_False;
  seqAjout.Clear();
  lines.Clear();
}

// ***************************************************************************
     //  etat1=12 pas tangent,pas passant
     //  etat1=11 tangent,pas passant
     //  etat1=2  pas tangent,passant
     //  etat1=1  tangent,passant
     //  lorsque un point a ete traite son etat devient negatif.
// ***************************************************************************
     //  etat2=13  point de demarage interieur sur ligne ferme
     //  etat2=12  point de demarage interieur sur ligne ouverte
     //            (ligne initialement fermee -> la ligne s est ouverte)       
     //  lorsque un point a ete traite (ou si on passe dessus lors du 
     //  cheminement) son etat devient negatif.
// ****************************************************************************

//
// Perform avec points interieurs
//
void IntWalk_IWalking::Perform(const ThePOPIterator& Pnts1,
			       const ThePOLIterator& Pnts2,
			       TheIWFunction& Func,
			       const ThePSurface& Caro,
			       const Standard_Boolean Reversed)

{

  Standard_Integer I;
  Standard_Boolean Rajout = Standard_False;
  Standard_Integer nbPnts1 = Pnts1.Length();
  Standard_Integer nbPnts2 = Pnts2.Length();
  Standard_Real U,V;

  Clear();
  reversed = Reversed;


  // Chargement de etat1 et etat2  et des ustart et vstart.

  TColStd_SequenceOfReal Umult;
  TColStd_SequenceOfReal Vmult;

  Standard_Integer decal=0;
  wd1.reserve (nbPnts1+decal);
  nbMultiplicities.reserve (nbPnts1+decal);
  for (I=1;I <= nbPnts1+decal; I++) {
    const ThePointOfPath& PathPnt = Pnts1.Value(I-decal);
    IntWalk_WalkingData aWD1;
    aWD1.etat = 1;
    if (!ThePointOfPathTool::IsPassingPnt(PathPnt)) 
      aWD1.etat = 11;
    if (!ThePointOfPathTool::IsTangent(PathPnt))   
      ++aWD1.etat;

    if(aWD1.etat==2) {  //-- lbr le 15 fev 99 
      aWD1.etat=11;
    }      

    ThePointOfPathTool::Value2d(PathPnt, aWD1.ustart, aWD1.vstart);
    wd1.push_back (aWD1);
    Standard_Integer aNbMult = ThePointOfPathTool::Multiplicity(PathPnt);
    nbMultiplicities.push_back(aNbMult);

    for (Standard_Integer J = 1; J <= aNbMult; J++) {
      ThePointOfPathTool::Parameters(PathPnt, J, U, V);
      Umult.Append(U);
      Vmult.Append(V);
    }
  }

  wd2.reserve (nbPnts2);
  for (I = 1; I <= nbPnts2; I++) {
    IntWalk_WalkingData aWD2;
    aWD2.etat = 13;
    ThePointOfLoopTool::Value2d(Pnts2.Value(I), aWD2.ustart, aWD2.vstart);
    wd2.push_back (aWD2);
  }

  tolerance(1) = ThePSurfaceTool::UResolution(Caro,Precision::Confusion());
  tolerance(2) = ThePSurfaceTool::VResolution(Caro,Precision::Confusion());

  Um = ThePSurfaceTool::FirstUParameter(Caro);
  Vm = ThePSurfaceTool::FirstVParameter(Caro);
  UM = ThePSurfaceTool::LastUParameter(Caro);
  VM = ThePSurfaceTool::LastVParameter(Caro);

  if (UM < Um) {
    Standard_Real utemp = UM;
    UM = Um;
    Um = utemp;
  }
  if (VM < Vm) {
    Standard_Real vtemp = VM;
    VM = Vm;
    Vm = vtemp;
  }

  Func.Set(Caro);

  // calcul de toutes les lignes ouvertes   
  if (nbPnts1 != 0) ComputeOpenLine(Umult,Vmult,Pnts1,Func,Rajout); 
  // calcul de toutes les lignes fermees 
  if (nbPnts2 != 0) ComputeCloseLine(Umult,Vmult,Pnts1,Pnts2,Func,Rajout); 
  for (I = 1; I <= nbPnts1; I++) { 
    if (wd1[I].etat >0) seqSingle.Append(Pnts1(I));
  }
  done = Standard_True;
}



//
// Perform sans point interieur
//

void IntWalk_IWalking::Perform(const ThePOPIterator& Pnts1,
			       TheIWFunction& Func,
			       const ThePSurface& Caro,
			       const Standard_Boolean Reversed)

{
  Standard_Integer I;
  Standard_Boolean Rajout = Standard_False;
  Standard_Integer nbPnts1 = Pnts1.Length();
  Standard_Real U,V;

  reversed = Reversed;


  // Chargement de etat1 et de ustart1 et vstart1.

  TColStd_SequenceOfReal Umult;
  TColStd_SequenceOfReal Vmult;

  wd1.reserve (nbPnts1);
  for (I=1;I <= nbPnts1; I++) {
    const ThePointOfPath& PathPnt = Pnts1.Value(I);
    IntWalk_WalkingData aWD1;
    aWD1.etat = 1;
    if (!ThePointOfPathTool::IsPassingPnt(PathPnt)) aWD1.etat = 11; 
    if (!ThePointOfPathTool::IsTangent(PathPnt))   ++aWD1.etat;
    ThePointOfPathTool::Value2d(PathPnt, aWD1.ustart, aWD1.vstart);
    wd1.push_back (aWD1);
    Standard_Integer aNbMult = ThePointOfPathTool::Multiplicity(PathPnt);
    nbMultiplicities.push_back(aNbMult);

    for (Standard_Integer J = 1; J <= aNbMult; J++) {
      ThePointOfPathTool::Parameters(PathPnt, J, U, V);
      Umult.Append(U);
      Vmult.Append(V);
    }
  }

  tolerance(1) = ThePSurfaceTool::UResolution(Caro,Precision::Confusion());
  tolerance(2) = ThePSurfaceTool::VResolution(Caro,Precision::Confusion());

  Um = ThePSurfaceTool::FirstUParameter(Caro);
  Vm = ThePSurfaceTool::FirstVParameter(Caro);
  UM = ThePSurfaceTool::LastUParameter(Caro);
  VM = ThePSurfaceTool::LastVParameter(Caro);

  if (UM < Um) {
    Standard_Real utemp = UM;
    UM = Um;
    Um = utemp;
  }
  if (VM < Vm) {
    Standard_Real vtemp = VM;
    VM = Vm;
    Vm = vtemp;
  }

  Func.Set(Caro);

  // calcul de toutes les lignes ouvertes   
  if (nbPnts1 != 0) ComputeOpenLine(Umult,Vmult,Pnts1,Func,Rajout); 

  for (I = 1; I <= nbPnts1; I++) { 
    if (wd1[I].etat >0) seqSingle.Append(Pnts1(I));
  }
  done = Standard_True;
}



