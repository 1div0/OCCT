# ==========================================================================#
# Brief:  This script compiles OCCT documents from *.md files to HTML pages #
# ==========================================================================#

# ======================================
#  Common functions
# ======================================

# Print single line or print the line to the file
function(puts theLine)
  if(${ARGC} EQUAL 1)
    message(STATUS "${theLine}")
  elseif(${ARGC} EQUAL 2)
    file(APPEND ${ARGV0} "${ARGV1}\n")
  endif()
endfunction()

# Print CMake Error, stop processing and generation
function(error theLine)
  message(FATAL_ERROR "${theLine}")
endfunction()

# Prints help message
function (OCCDoc_PrintHelpMessage)
  puts("Usage: gendoc [-h] {-refman|-overview} [-html|-pdf|-chm] [-m=<list of modules>|-ug=<list of docs>] [-v] [-s=<search_mode>] [-mathjax=<path>]")
  puts("")
  puts("Options are:")
  puts("")
  puts("choice of documentation to be generated:")
  puts("  -overview          : To generate Overview and User Guides")
  puts("                       (cannot be used with -refman)")
  puts("  -refman            : To generate class Reference Manual")
  puts("                       (cannot be used with -overview)")
  puts("")
  puts("choice of output format:")
  puts("  -html              : To generate HTML files")
  puts("                       (default, cannot be used with -pdf or -chm)")
  puts("  -pdf               : To generate PDF files")
  puts("                       (cannot be used with -refman, -html, or -chm)")
  puts("  -chm               : To generate CHM files")
  puts("                       (cannot be used with -html or -pdf)")
  puts("")
  puts("additional options:")
  puts("  -m=<modules_list>  : List of OCCT modules (separated with comma),")
  puts("                       for generation of Reference Manual")
  puts("  -ug=<docs_list>    : List of MarkDown documents (separated with comma),")
  puts("                       to use for generation of Overview / User Guides")
  puts("  -mathjax=<path>    : To use local or alternative copy of MathJax")
  puts("  -s=<search_mode>   : Specifies the Search mode of HTML documents")
  puts("                       Can be: none | local | server | external")
  puts("  -h                 : Prints this help message")
  puts("  -v                 : Enables more verbose output")
endfunction()

# A command for User Documentation compilation
function (gendoc)
  # Parameters
  set (DOC_TYPE "REFMAN")
  set (GEN_MODE "HTML_ONLY")
  set (DOCFILES)
  set (MODULES)
  set (DOCLABEL "")
  set (VERB_MODE "NO")
  set (SEARCH_MODE "none")
  set (MATHJAX_LOCATION "http://cdn.mathjax.org/mathjax/latest")
  set (mathjax_js_name "MathJax.js")
  set (DOCTYPE_COMBO_FLAG 0)
  set (GENMODE_COMBO_FLAG 0)
  set (GENERATE_PRODUCTS_REFMAN "NO")

  #available_docfiles;   # The full list of md files for HTML or CHM generation
  #available_pdf;        # The full list of md files for PDF generation
  #args_names
  #args_values

  # Load list of docfiles
  OCCDoc_LoadFilesList()

  # Parse CL arguments
  OCCDoc_ParseArguments(${ARGV})

  # Print help message if no arguments provided
  separate_arguments(args_names)
  list(LENGTH args_names length)
  if (${length} EQUAL 0)
    OCCDoc_PrintHelpMessage()
    return()
  endif()

  list(FIND args_names "pdf" FIND_pdf)
  list(FIND args_names "chm" FIND_chm)
  list(FIND args_names "ug"  FIND_ug)
  list(FIND args_names "m"  FIND_m)
  list(FIND args_names "refman" FIND_refman)
  list(FIND args_names "overview" FIND_overview)
  foreach (arg_n ${args_names})
    if ("${arg_n}" STREQUAL "h")
      OCCDoc_PrintHelpMessage()
      return()
    elseif ("${arg_n}" STREQUAL "html")
      if(${FIND_refman} EQUAL -1 AND ${FIND_overview} EQUAL -1 )
        error("Error: Please specify -refman or -overview argument.")
      endif()
      if(${FIND_refman} EQUAL -1)
        if (NOT ${GENMODE_COMBO_FLAG} EQUAL 1)
          set (GEN_MODE "HTML_ONLY")
          set (GENMODE_COMBO_FLAG 1)
        else()
          error("Error: Options -html, -pdf and -chm can not be combined.")
        endif()
      endif()
    elseif ("${arg_n}" STREQUAL "chm")
      if(${FIND_refman} EQUAL -1 AND ${FIND_overview} EQUAL -1 )
        error("Error: Please specify -refman or -overview argument.")
      endif()
      if(${FIND_refman} EQUAL -1)
        if(NOT ${GENMODE_COMBO_FLAG} EQUAL 1)
          set (GEN_MODE "CHM_ONLY")
          set (GENMODE_COMBO_FLAG 1)
        else()
          error("Error: Options -html, -pdf and -chm cannot be combined.")
        endif()
      endif()
    elseif ("${arg_n}" STREQUAL "pdf")
      if(${FIND_refman} EQUAL -1 AND ${FIND_overview} EQUAL -1 )
        error("Error: Please specify -refman or -overview argument.")
      endif()
      if(${FIND_refman} EQUAL -1)
        if (NOT ${GENMODE_COMBO_FLAG} EQUAL 1)
          set (GEN_MODE "PDF_ONLY")
          set (GENMODE_COMBO_FLAG 1)
        else()
          error("Error: Options -html, -pdf and -chm cannot be combined.")
        endif()
      endif()
    elseif ("${arg_n}" STREQUAL "overview")
      if (NOT ${DOCTYPE_COMBO_FLAG} EQUAL 1)
        set (DOC_TYPE "OVERVIEW")
        set (DOCTYPE_COMBO_FLAG 1)
      else()
        error("Error: Options -refman and -overview cannot be combined.")
      endif()
      # Print ignored options
      if ( NOT ${FIND_m} EQUAL -1 )
        puts ("Info: The following options will be ignored:")
        puts ("  * -m")
      endif()
      puts ("")
    elseif ("${arg_n}" STREQUAL "refman")
      if (NOT ${DOCTYPE_COMBO_FLAG} EQUAL 1)
        set (DOC_TYPE "REFMAN")
        set (DOCTYPE_COMBO_FLAG 1)
        if ( EXISTS "${PRODUCTS_SOURCE_DIR}/src/VAS/Products.tcl")
          set (GENERATE_PRODUCTS_REFMAN "YES")
        endif()
      else()
        error("Error: Options -refman and -overview cannot be combined.")
      endif()
      # Print ignored options
      if (NOT ${FIND_pdf} EQUAL -1 OR NOT ${FIND_chm} EQUAL -1 OR NOT ${FIND_ug} EQUAL -1)
        puts ("Info: The following options will be ignored:")
        if (NOT ${FIND_pdf} EQUAL -1)
          puts ("  * -pdf")
        endif()
        if (NOT ${FIND_chm} EQUAL -1)
          puts ("  * -chm")
        endif()
        if (NOT ${FIND_ug} EQUAL -1)
          puts ("  * -ug")
        endif()
        puts("")
      endif()
      if ( "${GENERATE_PRODUCTS_REFMAN}" STREQUAL "YES")
        if (${FIND_m} EQUAL -1)
          error("Error: Cannot generate Reference Manual for the whole set of OCC Products.")
        endif()
      endif()
    elseif ("${arg_n}" STREQUAL "v")
      set (VERB_MODE "YES")
    elseif ("${arg_n}" STREQUAL "ug")
      if(${FIND_refman} EQUAL -1)
        list(FIND args_names "ug" curIndex)
        list(GET args_values ${curIndex} curValue)
        if ( NOT "${curValue}" STREQUAL "NULL")
          string(REPLACE "," " " curValue "${curValue}")
          separate_arguments(curValue)
          set (DOCFILES ${curValue})
        else()
          error("Error in argument ug.")
        endif()
        # Check if all chosen docfiles are correct
        foreach (docfile ${DOCFILES})
          if(${FIND_pdf} EQUAL -1)
            # Check to generate HTMLs
            list(FIND available_docfiles "${docfile}" FIND_doc)
            if (${FIND_doc} EQUAL -1)
              error("Error: File \"${docfile}\" is not presented in the list of available docfiles.")
            endif()
          else()
            # Check to generate PDFs
            list(FIND available_pdf "${docfile}" FIND_doc)
            if ( ${FIND_doc} EQUAL -1)
              error("Error: File \"${docfile}\" is not presented in the list of generic PDFs.")
            endif()
          endif()
        endforeach()
      endif()
    elseif ("${arg_n}" STREQUAL "m")
      if (${FIND_overview} EQUAL -1)
        list(FIND args_names "m" curIndex)
        list(GET args_values ${curIndex} curValue)
        if ( NOT "${curValue}" STREQUAL "NULL")
          string(REPLACE "," " " curValue "${curValue}")
          separate_arguments(curValue)
          set(MODULES ${curValue})
        else()
          error("Error in argument m.")
        endif()
      endif()
    elseif ("${arg_n}" STREQUAL "s")
      if (${FIND_pdf} EQUAL -1)
        list(FIND args_names "s" curIndex)
        list(GET args_values ${curIndex} curValue)
        if ( NOT "${curValue}" STREQUAL "NULL")
          string(REPLACE "," " " curValue "${curValue}")
          separate_arguments(curValue)
          set (SEARCH_MODE ${curValue})
        else()
          error("Error in argument s.")
        endif()
      endif()
    elseif ("${arg_n}" STREQUAL "mathjax")
      if (NOT ${FIND_pdf} EQUAL -1)
        list(FIND args_names "mathjax" curIndex)
        list(GET args_values ${curIndex} curValue)
        string(REPLACE "," " " curValue "${curValue}")
        separate_arguments(curValue)
        set (possible_mathjax_loc ${curValue})
        if (EXISTS "${possible_mathjax_loc}/${mathjax_js_name}")
          set (MATHJAX_LOCATION ${curValue})
          puts ("${MATHJAX_LOCATION}")
        else()
          puts ("Warning: ${mathjax_js_name} is not found in ${possible_mathjax_loc}.")
          puts ("         MathJax will be used from ${MATHJAX_LOCATION}")
        endif()
      else()
        puts("Warning: MathJax is not used with pdf and will be ignored.")
      endif()
    else()
      OCCDoc_PrintHelpMessage()
      error("Wrong argument: ${arg_n}")
    endif()
  endforeach()

  # Check the existence of the necessary tools
  find_program(DOC_DOXYGEN_PATH "doxygen")
  if ("${DOC_DOXYGEN_PATH}" STREQUAL "DOC_DOXYGEN_PATH-NOTFOUND")
    error(" Aborting... Could not find Doxygen, check DOC_DOXYGEN_PATH variable")
  endif()

  if("${DOC_TYPE}" STREQUAL "REFMAN")
    find_program(DOC_GRAPHVIZ_PATH "dot")
    if ("${DOC_GRAPHVIZ_PATH}" STREQUAL "DOC_GRAPHVIZ_PATH-NOTFOUND")
      puts("Warning: Could not find Dot Part of Graphviz software. Doxygen will skip generation of class diagrams in Reference Manual, check DOC_GRAPHVIZ_PATH variable")
    endif()
  endif()

  if (WIN32)
    if ("${GEN_MODE}" STREQUAL "CHM_ONLY")
      find_program(DOC_HHC_PATH "hhc")
      if("${DOC_HHC_PATH}" STREQUAL "DOC_HHC_PATH-NOTFOUND")
        error(" Aborting... Could not find HHC, check DOC_HHC_PATH variable")
      endif()
    endif()
  endif()

  if ("${GEN_MODE}" STREQUAL "PDF_ONLY")
    find_program(DOC_INKSCAPE_PATH "inkscape")
    if("${DOC_INKSCAPE_PATH}" STREQUAL "DOC_INKSCAPE_PATH-NOTFOUND")
      puts ("Warning: Could not find Inkscape, check DOC_INKSCAPE_PATH variable.")
      puts ("\tSVG images will be lost in PDF documents.")
    endif()
    find_program(DOC_PDFLATEX_PATH "pdflatex")
    if("${DOC_PDFLATEX_PATH}" STREQUAL "DOC_PDFLATEX_PATH-NOTFOUND")
      error(" Aborting... Could not find PDFLATEX, check DOC_PDFLATEX_PATH variable")
    endif()
  endif()

  # If we do not specify list for docfiles with -m argument,
  # we assume that we have to generate all docfiles
  list(LENGTH DOCFILES DOCFILES_length)
  if (${DOCFILES_length} EQUAL 0)
    if (NOT "${GEN_MODE}" STREQUAL "PDF_ONLY")
      set (DOCFILES ${available_docfiles})
    else()
      set (DOCFILES ${available_pdf})
    endif()
  endif()

  OCCDoc_GetRootDir(ROOTDIR)

  # Clean logfiles
  set (OUTDIR  "${ROOTDIR}/doc")
  set (DOXYLOG "${OUTDIR}/doxygen_warnings_and_errors.log")
  set (PDFLOG  "${OUTDIR}/pdflatex_warnings_and_errors.log")

  file(REMOVE "${PDFLOG}")
  file(REMOVE "${DOXYLOG}")

  # Start main activities
  if (NOT "${GEN_MODE}" STREQUAL "PDF_ONLY")
    OCCDoc_Main(${DOC_TYPE} DOCFILES MODULES ${GEN_MODE} ${VERB_MODE} ${SEARCH_MODE} ${MATHJAX_LOCATION} ${GENERATE_PRODUCTS_REFMAN} available_docfiles available_pdf)
  else()
    puts ("Generating OCCT User Guides in PDF format...")
    foreach (pdf ${DOCFILES})
      puts ("Info: Processing file ${pdf}")
      # Some values are hardcoded because they are related only to PDF generation
      separate_arguments(pdf)
      OCCDoc_Main("OVERVIEW" pdf "" "PDF_ONLY" ${VERB_MODE} "none" ${MATHJAX_LOCATION} "NO" available_docfiles available_pdf)
    endforeach()
    string(TIMESTAMP time "%Y-%m-%d %H:%M")
    puts ("${time} Generation completed.")
    puts ("PDF files are generated in \n\t${OUTDIR}/pdf")
  endif()
endfunction()

# Main procedure for documents compilation
function (OCCDoc_Main docType docfiles modules generatorMode verboseMode searchMode mathjaxLocation generateProductsRefman the_available_docfiles the_available_pdf)
  set(docfiles ${${docfiles}})
  set(modules ${${modules}})
  set(available_docfiles ${${the_available_docfiles}})
  set(available_pdf ${${the_available_pdf}})

  if ("${generateProductsRefman}" STREQUAL "YES")
    set (ROOTDIR "${PRODUCTS_SOURCE_DIR}")
  else()
    set (ROOTDIR "${OCCT_SOURCE_DIR}")
  endif()

  OCCDoc_GetDoxDir(INDIR)
  set (OUTDIR     "${ROOTDIR}/doc")
  set (PDFDIR     "${OUTDIR}/pdf")
  set (UGDIR      "${PDFDIR}/user_guides")
  set (DGDIR      "${PDFDIR}/dev_guides")
  set (TAGFILEDIR "${OUTDIR}/refman")
  set (HTMLDIR    "${OUTDIR}/overview/html")
  set (LATEXDIR   "${OUTDIR}/overview/latex")
  set (DOXYFILE   "${OUTDIR}/OCCT.cfg")

  # Create or cleanup the output folders
  if (NOT "${generateProductsRefman}" STREQUAL "YES")
    foreach(dir ${OUTDIR} ${HTMLDIR} ${PDFDIR} ${UGDIR} ${DGDIR})
      if (NOT EXISTS "${dir}")
        file(MAKE_DIRECTORY "${dir}")
      endif()
    endforeach()
    if (EXISTS "${LATEXDIR}")
      file(REMOVE_RECURSE "${LATEXDIR}")
    endif()
    file(MAKE_DIRECTORY "${LATEXDIR}")
  endif()
  if ("${docType}" STREQUAL "REFMAN")
    if (NOT EXISTS "${TAGFILEDIR}")
      file(MAKE_DIRECTORY "${TAGFILEDIR}")
    endif()
  endif()

  # is MathJax HLink?
  set (mathjax_relative_location "${mathjaxLocation}")
  if (IS_DIRECTORY "${mathjaxLocation}")
    if ( "${generatorMode}" STREQUAL "HTML_ONLY")
      # related path
      file(RELATIVE_PATH mathjax_relative_location ${HTMLDIR} ${mathjaxLocation})
    elseif ("${generatorMode}" STREQUAL "CHM_ONLY")
      # absolute path
      set (mathjax_relative_location ${mathjaxLocation})
    endif()
  endif()

  if ( "${generateProductsRefman}" STREQUAL "YES")
    set (DOCDIR "${OUTDIR}/refman")
    puts ("Generating OCC Products Reference Manual")
  else()
    if ( "${docType}" STREQUAL "REFMAN")
      set (DOCDIR "${OUTDIR}/refman")
      puts ("Generating Open CASCADE Reference Manual")
    elseif ("${docType}" STREQUAL "OVERVIEW")
      set (DOCDIR "${OUTDIR}/overview")
      set (FORMAT "")
      if ( "${generatorMode}" STREQUAL "HTML_ONLY" OR "${generatorMode}" STREQUAL "CHM_ONLY")
        if ( "${generatorMode}" STREQUAL "HTML_ONLY")
          set (FORMAT " in HTML format...")
        elseif ( "${generatorMode}" STREQUAL "CHM_ONLY")
          set (FORMAT " in CHM format...")
        endif()
        puts ("Generating OCCT User Guides${FORMAT}")
      endif()
    else()
      error("Error: Invalid documentation type: ${docType}. Can not process.")
    endif()
  endif()

  # Generate Doxyfile
  string(TIMESTAMP time "%Y-%m-%d %H:%M")
  puts ("${time} Generating Doxyfile...")

  OCCDoc_MakeDoxyfile(${docType} ${DOCDIR} ${TAGFILEDIR} ${DOXYFILE} ${generatorMode} docfiles modules ${verboseMode} ${searchMode} ${mathjax_relative_location})

  # Run doxygen tool
  string(TIMESTAMP starttimestamp "%Y-%m-%d %H:%M")
  if ("${generatorMode}" STREQUAL "HTML_ONLY" OR "${docType}" STREQUAL "REFMAN")
    puts("${starttimestamp} Generating HTML files...")
    # Copy index file to provide fast access to HTML documentation
    file(COPY "${INDIR}/resources/index.html" DESTINATION "${DOCDIR}")
  elseif ("${generatorMode}" STREQUAL "CHM_ONLY")
    puts ("${starttimestamp} Generating CHM file...")
  elseif ("${generatorMode}" STREQUAL "PDF_ONLY")
    puts ("${starttimestamp} Generating PDF file...")
  endif()
  execute_process(COMMAND ${DOC_DOXYGEN_PATH} ${DOXYFILE}
                  OUTPUT_FILE ${OUTDIR}/doxygen_out.log
                  ERROR_FILE ${OUTDIR}/doxygen_warnings_and_errors.log
                 )
  # Start Post Processing
  string(TIMESTAMP curtime "%Y-%m-%d %H:%M")
  if( "${docType}" STREQUAL "REFMAN")
    # Post Process generated HTML pages and draw dependency graphs
    OCCDoc_PostProcessor(${DOCDIR})
    if (${isOK} EQUAL 0)
      puts ("${curtime} Generation completed.")
      puts ("Info: doxygen log file is located in:")
      puts ("\t${OUTDIR}/doxygen_out.log.")
      puts ("Reference Manual is generated in \n\t${DOCDIR}")
    endif()
  elseif ("${docType}" STREQUAL "OVERVIEW")
    # Start PDF generation routine
    if ("${generatorMode}" STREQUAL "PDF_ONLY")
      # Prepare a list of TeX files, generated by Doxygen
      file(GLOB TEXFILES RELATIVE "${LATEXDIR}" "${LATEXDIR}/*.tex")
      list(REMOVE_ITEM TEXFILES "refman.tex")
      if ("${verboseMode}" STREQUAL "YES")
        puts ("Info: Preprocessing generated TeX files...")
      endif()

      OCCDoc_ProcessTex(TEXFILES ${LATEXDIR} ${verboseMode})

      if ("${verboseMode}" STREQUAL "YES")
        puts ("Info: Converting SVG images to PNG format...")
      endif()

      if (NOT "${DOC_INKSCAPE_PATH}" STREQUAL "DOC_INKSCAPE_PATH-NOTFOUND")
        OCCDoc_ProcessSvg(${LATEXDIR} ${verboseMode})
      endif()

      if ("${verboseMode}" STREQUAL "YES")
        puts ("Info: Generating PDF file from TeX files...")
      endif()
      foreach (TEX ${TEXFILES})
        # Rewrite existing REFMAN.tex file...
        get_filename_component(TEX ${TEX} NAME_WE)
        if ("${verboseMode}" STREQUAL "YES")
          puts ("Info: Generating PDF file from ${TEX}...")
        endif()

        OCCDoc_MakeRefmanTex(${TEX} ${LATEXDIR} ${verboseMode} available_pdf)

        if ("${verboseMode}" STREQUAL "YES")
          # ...and use it to generate PDF from TeX...
          if (WIN32)
            puts ("Info: Executing ${LATEXDIR}/make.bat...")
          else()
            puts ("Info: Executing ${LATEXDIR}/Makefile...")
          endif()
        endif()
        set (PDFLOG "${OUTDIR}/pdflatex_warnings_and_errors.log")

        if (WIN32)

          execute_process(COMMAND ${LATEXDIR}/make.bat
                  OUTPUT_FILE ${OUTDIR}/pdflatex_out.log
                  WORKING_DIRECTORY ${LATEXDIR}
                  ERROR_FILE ${OUTDIR}/pdflatex_warnings_and_errors.log
                 )
        else()
          execute_process(COMMAND make -f ${LATEXDIR}/Makefile
                  OUTPUT_FILE ${OUTDIR}/pdflatex_out.log
                  WORKING_DIRECTORY ${LATEXDIR}
                  ERROR_FILE ${OUTDIR}/pdflatex_warnings_and_errors.log
                 )
          # Small workaround for *nix stations
          execute_process(COMMAND ${DOC_PDFLATEX_PATH} ${LATEXDIR}/refman.tex
                  WORKING_DIRECTORY ${LATEXDIR}
                  OUTPUT_FILE ${OUTDIR}/pdflatex_out.log
                  ERROR_FILE ${OUTDIR}/pdflatex_warnings_and_errors.log
                 )
        endif()

        if (NOT EXISTS "${LATEXDIR}/refman.pdf")
          error("Fatal: PDFLaTeX failed to create output file, stopping!\n\tCheck \"${OUTDIR}/pdflatex_warnings_and_errors.log\" log file")
        endif()

        set (destFolder "${PDFDIR}")
        string(REGEX MATCHALL "([a-zA-Z]+)" parsed_string ${TEX})
        list(FIND parsed_string "tutorial" isTUTORIAL)
        list(FIND parsed_string "user" isUSER)
        list(FIND parsed_string "dev" isDEV)

        if (NOT ${isTUTORIAL} EQUAL -1)
          string(REPLACE "occt__" "occt_" TEX ${TEX})
          set (destFolder ${PDFDIR})
        elseif (NOT ${isUSER} EQUAL -1)
          string(REPLACE "user_guides__" "" TEX ${TEX})
          set (destFolder ${UGDIR})
        elseif (NOT ${isDEV} EQUAL -1)
          string(REPLACE "dev_guides__" "" TEX ${TEX})
          set (destFolder ${DGDIR})
        endif()
        file (RENAME "${LATEXDIR}/refman.pdf" "${destFolder}/${TEX}.pdf")
      endforeach()
    elseif ( "${generatorMode}" STREQUAL "CHM_ONLY" )
      file (RENAME "${OUTDIR}/overview.chm" "${OUTDIR}/occt_overview.chm")
    endif()
    if ( "${generatorMode}" STREQUAL "HTML_ONLY" )
      puts ("HTML documentation is generated in \n\t${DOCDIR}")
    endif()
    if ( "${generatorMode}" STREQUAL "CHM_ONLY" )
      puts ("Generated CHM documentation is in \n\t${OUTDIR}/overview.chm")
    endif()

    puts ("")
  endif()

  file(GLOB_RECURSE deleteList "${OUTDIR}/*.tmp")
  foreach(file ${deleteList})
    file (REMOVE ${file})
  endforeach()
endfunction()

# Generates Doxygen configuration file for Overview documentation
function (OCCDoc_MakeDoxyfile docType outDir tagFileDir doxyFileName generatorMode DocFilesList ModulesList verboseMode searchMode mathjaxLocation)
  set(DocFilesList ${${DocFilesList}})
  set(ModulesList ${${ModulesList}})
  OCCDoc_GetDoxDir(inputDir)
  set (TEMPLATES_DIR ${inputDir}/resources)
  OCCDoc_DetectCasVersion(occt_version)
  # Delete existent doxyfile
  file (REMOVE "${doxyFileName}")

  # Copy specific template to the target folder
  if ( "${docType}" STREQUAL "REFMAN")
    configure_file("${TEMPLATES_DIR}/occt_rm.doxyfile" "${doxyFileName}" COPYONLY)
  elseif ("${docType}" STREQUAL "OVERVIEW")
    if ("${generatorMode}" STREQUAL "HTML_ONLY" OR "${generatorMode}" STREQUAL "CHM_ONLY")
      configure_file("${TEMPLATES_DIR}/occt_ug_html.doxyfile" "${doxyFileName}" COPYONLY)
    elseif ("${generatorMode}" STREQUAL "PDF_ONLY")
      configure_file("${TEMPLATES_DIR}/occt_ug_pdf.doxyfile" "${doxyFileName}" COPYONLY)
    else()
      error("Error: Unknown generation mode")
    endif()
  else()
    error("Error: Cannot generate unknown document type")
  endif()

  # Write specific options
  if ("${docType}" STREQUAL "REFMAN")
    GET_OCCT_MODULES(modules)
    if (NOT "${ModulesList}" STREQUAL "")
      # Detect invalid names of modules
      foreach (module ${ModulesList})
        list(FIND modules "${module}" isFound)
        if (${isFound} EQUAL -1)
          error("Error: No module ${module} is known. Aborting...")
        endif()
      endforeach()
      set (modules "${ModulesList}")
    endif()

    # Set context
    list(LENGTH modules length)
    if (${length} EQUAL 1)
      set (title "OCCT ${modules}")
      set (name "${modules}")
    else()
      set (title "Open CASCADE Technology")
      set (name "OCCT")
    endif()

    # Get list of header files in the specified modules
    set (filelist)
    foreach (module ${modules})
      foreach (tk ${${module}_TOOLKITS})
        OCCDoc_GetPackagesList(${tk} ${tk}_PACKAGES)
        foreach (pk ${${tk}_PACKAGES})
          OCCDoc_GetRootDir(theRoot)
          file(GLOB INC_FILES "${theRoot}/src/${pk}/*.[hg]*")
          set(TEMP_INC_FILES)
          foreach (INC_FILE ${INC_FILES})
            string(FIND "${INC_FILE}" "/Handle_" isFound)
            if(${isFound} EQUAL -1)
              list(APPEND TEMP_INC_FILES "${INC_FILE}")
            endif()
          endforeach()
          list(APPEND filelist "${TEMP_INC_FILES}")
        endforeach()
      endforeach()
    endforeach()

    puts (${doxyFileName} "PROJECT_NAME           = \"${title}\"")
    puts (${doxyFileName} "PROJECT_NUMBER         = ${occt_version}")
    puts (${doxyFileName} "OUTPUT_DIRECTORY       = ${outDir}/.")
    puts (${doxyFileName} "GENERATE_TAGFILE       = ${outDir}/${name}.tag")

    if ("${searchMode}" STREQUAL "none")
      puts (${doxyFileName} "SEARCHENGINE           = NO")
      puts (${doxyFileName} "SERVER_BASED_SEARCH    = NO")
      puts (${doxyFileName} "EXTERNAL_SEARCH        = NO")
    else()
      puts (${doxyFileName} "SEARCHENGINE           = YES")
      if ("${searchMode}" STREQUAL "local")
        puts (${doxyFileName} "SERVER_BASED_SEARCH    = NO")
        puts (${doxyFileName} "EXTERNAL_SEARCH        = NO")
      elseif ("${searchMode}" STREQUAL "server")
        puts (${doxyFileName} "SERVER_BASED_SEARCH    = YES")
        puts (${doxyFileName} "EXTERNAL_SEARCH        = NO")
      elseif ("${searchMode}" STREQUAL "external")
        puts (${doxyFileName} "SERVER_BASED_SEARCH    = YES")
        puts (${doxyFileName} "EXTERNAL_SEARCH        = YES")
      else()
        error("Error: Wrong search engine type: ${searchMode}.")
      endif()
    endif()
    if(EXISTS "${DOC_GRAPHVIZ_PATH}")
      set(DOT_PATH "${DOC_GRAPHVIZ_PATH}")
    endif()
    puts (${doxyFileName} "DOTFILE_DIRS             = ${outDir}/html")
    puts (${doxyFileName} "DOT_PATH                 = ${DOT_PATH}")
    puts (${doxyFileName} "INCLUDE_PATH             = ${INSTALL_DIR}/inc")
    # list of files to generate
    OCCDoc_MakeMainPage(${outDir} "${outDir}/${name}.dox" modules)
    set (mainpage "${outDir}/${name}.dox")
    puts (${doxyFileName} "")
    puts (${doxyFileName} "INPUT    = ${mainpage} \\")
    foreach (header ${filelist})
      puts (${doxyFileName} "               ${header} \\")
    endforeach()

    puts (${doxyFileName} "MATHJAX_FORMAT         = HTML-CSS")
    puts (${doxyFileName} "MATHJAX_RELPATH        = ${mathjaxLocation}")

    puts (${doxyFileName} "")

  elseif ( "${docType}" STREQUAL "OVERVIEW")
    # Add common options for generation of Overview and User Guides
    puts (${doxyFileName} "PROJECT_NUMBER         = ${occt_version}")
    puts (${doxyFileName} "OUTPUT_DIRECTORY       = ${outDir}/.")
    puts (${doxyFileName} "PROJECT_LOGO           = ${inputDir}/resources/occ_logo.png")

    set (PARAM_INPUT "INPUT                 =")
    set (PARAM_IMAGEPATH "IMAGE_PATH        = ${inputDir}/resources/ ")
    foreach (docFile ${DocFilesList})
      set (NEW_IMG_PATH "${inputDir}/${docFile}")
      OCCDoc_GetRootDir(theRoot)
      if (NOT "${NEW_IMG_PATH}" STREQUAL "${theRoot}")
        get_filename_component(img_string ${NEW_IMG_PATH} DIRECTORY)
        set (img_string "${img_string}/images")
        if (EXISTS ${img_string})
          set(PARAM_IMAGEPATH "${PARAM_IMAGEPATH} ${img_string}")
        endif()
      endif()
      set(PARAM_INPUT "${PARAM_INPUT} ${inputDir}/${docFile}")
    endforeach()
    puts (${doxyFileName} ${PARAM_INPUT})
    puts (${doxyFileName} ${PARAM_IMAGEPATH})

    # Add document type-specific options
    if ( "${generatorMode}" STREQUAL "HTML_ONLY")
      # generate tree view
      puts (${doxyFileName} "GENERATE_TREEVIEW      = YES")

      # Set a reference to a TAGFILE
      if (NOT "${tagFileDir}" STREQUAL "")
        if (EXISTS "${tagFileDir}/OCCT.tag")
          set (tagPath ${tagFileDir})
          puts (${doxyFileName} "TAGFILES               = ${tagFileDir}/OCCT.tag=../../refman/html")
        endif()
      endif()
      # HTML Search engine options
      string(TOLOWER "${searchMode}" searchMode)
      if ("${searchMode}" STREQUAL "none")
        puts (${doxyFileName} "SEARCHENGINE           = NO")
        puts (${doxyFileName} "SERVER_BASED_SEARCH    = NO")
        puts (${doxyFileName} "EXTERNAL_SEARCH        = NO")
      else()
        puts (${doxyFileName} "SEARCHENGINE           = YES")
        if ("${searchMode}" STREQUAL "local")
          puts (${doxyFileName} "SERVER_BASED_SEARCH    = NO")
          puts (${doxyFileName} "EXTERNAL_SEARCH        = NO")
        elseif ("${searchMode}" STREQUAL "server")
          puts (${doxyFileName} "SERVER_BASED_SEARCH    = YES")
          puts (${doxyFileName} "EXTERNAL_SEARCH        = NO")
        elseif ("${searchMode}" STREQUAL "external")
          puts (${doxyFileName} "SERVER_BASED_SEARCH    = YES")
          puts (${doxyFileName} "EXTERNAL_SEARCH        = YES")
        else()
          error("Error: Wrong search engine type: ${searchMode}.")
        endif()
      endif()
    elseif ( "${generatorMode}" STREQUAL "CHM_ONLY")
      # specific options for CHM file generation
      if(EXISTS "${DOC_HHC_PATH}")
        set(HHC_LOCATION "${DOC_HHC_PATH}")
      endif()
      puts (${doxyFileName} "GENERATE_TREEVIEW      = NO")
      puts (${doxyFileName} "SEARCHENGINE           = NO")
      puts (${doxyFileName} "GENERATE_HTMLHELP      = YES")
      puts (${doxyFileName} "CHM_FILE               = ../../overview.chm")
      puts (${doxyFileName} "HHC_LOCATION           = \"${HHC_LOCATION}\"")
      puts (${doxyFileName} "DISABLE_INDEX          = YES")
    endif()

    # Formula options
    puts (${doxyFileName} "MATHJAX_RELPATH        = ${mathjaxLocation}")
  endif()
endfunction()

# Parses arguments line like "-arg1=val1 -arg2=val2 ..." to array args_names and map args_values
function (OCCDoc_ParseArguments)
  #args_names
  #args_values
  set (args_names)
  set (args_values)

  separate_arguments(ARGV)

  string(REGEX MATCHALL "^[a-zA-Z]+$" single_var "${ARGV}")
  string(REGEX MATCHALL "^[a-zA-Z]+[=].*$" multi_var "${ARGV}")

  separate_arguments(ARGV)
  foreach (arg ${ARGV})
    STRING(FIND "${arg}" "=" equalChar)
    STRING(FIND "${arg}" "-" firstChar)
    if(NOT "${firstChar}" EQUAL 0)
      error("Error in argument \"${arg}\".")
    endif()
    if(NOT "${equalChar}" EQUAL -1)
      math(EXPR valueChar "${equalChar} + 1")
      math(EXPR nameChar "${equalChar} - 1")
      string(SUBSTRING "${arg}" "${valueChar}" -1 aValue)
      string(SUBSTRING "${arg}" 1 "${nameChar}" aName)
    else()
      string(SUBSTRING "${arg}" 1 -1 aName)
      set(aValue "NULL")
    endif()
    list(APPEND args_names "${aName}")
    list(APPEND args_values "${aValue}")
  endforeach()
  set (args_names ${args_names} PARENT_SCOPE)
  set (args_values ${args_values} PARENT_SCOPE)
  set (isOK 0 PARENT_SCOPE)
endfunction()

# Returns script parent folder
function (OCCDoc_GetDoxDir result)
  if (BUILD_PATCH_DIR AND EXISTS "${BUILD_PATCH_DIR}/dox")
    set (filePATH ${BUILD_PATCH_DIR})
  elseif (EXISTS "${CMAKE_SOURCE_DIR}/dox")
    set (filePATH ${CMAKE_SOURCE_DIR})
  endif()
  set(${result} "${filePATH}/dox" PARENT_SCOPE)
endfunction()

# Returns OCCT root dir
function (OCCDoc_GetOCCTRootDir result)
  OCCDoc_GetDoxDir(path)
  get_filename_component(path "${path}" DIRECTORY)
  set(${result} "${path}" PARENT_SCOPE)
endfunction()

# Returns root dir
function (OCCDoc_GetRootDir result)
  OCCDoc_GetOCCTRootDir(path)
  set(${result} "${path}" PARENT_SCOPE)
endfunction()

# Returns OCCT source dir
function (OCCDoc_GetSourceDir result)
  OCCDoc_GetRootDir(theRoot)
  set(${result} "${theRoot}/src" PARENT_SCOPE)
endfunction()

# Returns OCCT version string from file Standard_Version.hxx (if available)
function (OCCDoc_DetectCasVersion theVersion)
  set (occt_ver 6.7.0)
  set (occt_ver_add "")
  OCCDoc_GetSourceDir(filename)
  set(filename "${filename}/Standard/Standard_Version.hxx")
  if(EXISTS "${filename}")
    foreach (var OCC_VERSION_COMPLETE OCC_VERSION_DEVELOPMENT)
      file (STRINGS "${filename}" ${var} REGEX "^#define ${var} .*")
      STRING(REGEX REPLACE ".*${var} .*\"([^ ]+)\".*" "\\1" ${var} "${${var}}" )
    endforeach()
    if(NOT "${OCC_VERSION_DEVELOPMENT}" STREQUAL "")
      set(${theVersion} "${OCC_VERSION_COMPLETE}.${OCC_VERSION_DEVELOPMENT}" PARENT_SCOPE)
    else()
      set(${theVersion} "${OCC_VERSION_COMPLETE}" PARENT_SCOPE)
    endif()
  endif()
endfunction()

# Convert SVG files to PDF format to allow including them to PDF
# (requires InkScape to be in PATH)
function (OCCDoc_ProcessSvg latexDir verboseMode)
  file(GLOB aFILES "${latexDir}/*.svg")
  foreach (file ${aFILES})
    if ("${verboseMode}" STREQUAL "YES")
      puts ("Info: Converting file ${file}...")
    endif()
    get_filename_component(aDir ${file} DIRECTORY )
    get_filename_component(aName ${file} NAME_WE )
    set (pdffile "${aDir}/${aName}.pdf")
    execute_process(COMMAND ${DOC_INKSCAPE_PATH} -z -D --file=${file} --export-pdf=${pdffile}
        WORKING_DIRECTORY ${LATEXDIR}
        OUTPUT_FILE ${OUTDIR}/inkscape_out.log
        ERROR_FILE ${OUTDIR}/inkscape_warnings_and_errors.log
    )
  endforeach()
endfunction()

# ==============================================
# Reference Manual-specific functions
# ==============================================

# Finds dependencies between all modules
function (OCCDoc_CreateModulesDependencyGraph dir filename modules mpageprefix)
  set(modules ${${modules}})
  #module_dependency
  set (file "${dir}/${filename}.dot")
  file(REMOVE ${file})
  puts (${file} "digraph ${filename}")
  puts (${file} "{")
  foreach (mod ${modules})
    if ( NOT "${mod}" STREQUAL "")
      string(TOLOWER "${mpageprefix}${mod}.html" aLowerString)
      puts (${file} "\t${mod} [ URL = \"${aLowerString}\" ]")
      foreach (mod_depend ${${mod}_DEPS})
        puts (${file} "\t${mod_depend} -> ${mod} [ dir = \"back\", color = \"midnightblue\", style = \"solid\" ]")
      endforeach()
    endif()
  endforeach()
  puts (${file} "}")
endfunction()

# Finds dependencies between all toolkits in module
function(OCCDoc_CreateModuleToolkitsDependencyGraph dir filename modulename tpageprefix)
  #toolkits_in_module
  #toolkit_dependency
  #toolkit_parent_module
  set (file "${dir}/${filename}.dot")
  file(REMOVE ${file})
  puts (${file} "digraph ${filename}")
  puts (${file} "{")
  foreach (tk ${${modulename}_TOOLKITS})
    string(TOLOWER "${tpageprefix}${tk}.html" LowerString)
    OCC_GetUnitType("${tk}" theType)
    if("${theType}" STREQUAL "t")
      puts (${file} "\t${tk} [ URL = \"${LowerString}\"]")
      foreach (tkd ${${tk}_DEPS})
        IS_OCCT_TOOLKIT(${tkd})
        OCC_GetUnitType("${tkd}" theType)
        if("${theType}" STREQUAL "t")
          if(NOT ${isFOUND} EQUAL -1)
            if("${isFOUND}" STREQUAL "${modulename}")
              puts (${file} "\t${tkd} -> ${tk} [ dir = \"back\", color = \"midnightblue\", style = \"solid\" ]")
            endif()
          endif()
        endif()
      endforeach()
    endif()
  endforeach()
  puts (${file} "}")
endfunction()

# Finds dependencies between the current toolkit and other toolkits
function(OCCDoc_CreateToolkitDependencyGraph dir filename toolkitname tpageprefix)
  #toolkit_dependency
  set (file "${dir}/${filename}.dot")
  file(REMOVE ${file})
  puts(${file} "digraph ${filename}")
  puts(${file} "{")
  string(TOLOWER "${tpageprefix}${toolkitname}.html" LowerString)
  puts(${file} "\t${toolkitname} [ URL = \"${LowerString}\", shape = box ]")
  foreach (tkd ${${toolkitname}_DEPS})
    string(TOLOWER "${tpageprefix}${tkd}.html" LowerString)
    puts(${file} "\t${tkd} [ URL = \"${LowerString}\"\ , shape = box ]")
    puts(${file} "\t${toolkitname} -> ${tkd} [ color = \"midnightblue\", style = \"solid\" ]")
  endforeach()
  list(LENGTH ${toolkitname}_DEPS length)
  if (${length} GREATER 1)
    puts(${file} "\taspect = 1")
  endif()
  puts(${file} "}")
endfunction()

# Fills arrays of modules, toolkits, dependency of modules/toolkits etc
function (OCCDoc_LoadData)
  #toolkits_in_module
  #toolkit_dependency
  #toolkit_parent_module
  #module_dependency
  GET_OCCT_MODULES(modules)
  set(MODULES ${modules} PARENT_SCOPE)
  foreach (mod ${modules})
    set(${mod}_TOOLKITS "${${mod}_TOOLKITS}" PARENT_SCOPE)
    foreach (tk ${${mod}_TOOLKITS})
      OCCT_TOOLKIT_DEP(${tk})
      foreach (dtk ${${tk}_DEPS})
        IS_OCCT_TOOLKIT(${dtk})
        if(${isFOUND} EQUAL -1)
          list(REMOVE_ITEM ${tk}_DEPS ${dtk})
        endif()
      endforeach()
      set(${tk}_DEPS ${${tk}_DEPS} PARENT_SCOPE)
    endforeach()
  endforeach()

  # Get modules dependency
  foreach (mod ${modules})
    set(${mod}_DEPS)
    foreach (tk ${${mod}_TOOLKITS})
      foreach(dtk ${${tk}_DEPS})
        IS_OCCT_TOOLKIT(${dtk})
        if(NOT ${isFOUND} EQUAL -1)
          if(NOT "${mod}" STREQUAL "${isFOUND}")
            list(APPEND ${mod}_DEPS "${isFOUND}")
          endif()
        endif()
      endforeach()
    endforeach()
    list(LENGTH ${mod}_DEPS length)
    if(NOT ${length} EQUAL 0)
      list(REMOVE_DUPLICATES ${mod}_DEPS)
    endif()
    set(${mod}_DEPS ${${mod}_DEPS} PARENT_SCOPE)
  endforeach()
endfunction()

# Returns list of packages of the given toolkit
function (OCCDoc_GetExternLibList theToolkit theExternLibs)
  OCCDoc_GetRootDir(theRoot)
  # Open file with list of packages of the given toolkit
  file(READ "${theRoot}/src/${theToolkit}/EXTERNLIB" CONTENT)
  set(${theExternLibs} ${CONTENT} PARENT_SCOPE)
endfunction()

# Returns list of packages of the given toolkit
function (OCC_GetUnitType theName theResult)
  OCCDoc_GetRootDir(theRoot)
  # Open file with list of packages of the given toolkit
  set(aType "")
  if(EXISTS "${theRoot}/adm/UDLIST")
    file(STRINGS "${theRoot}/adm/UDLIST" CONTENT REGEX ". ${theName}")
  endif()
  string(SUBSTRING "${CONTENT}" 0 1 aType)
  set(${theResult} "${aType}" PARENT_SCOPE)
endfunction()

# Returns list of packages of the given toolkit
function (OCCDoc_GetPackagesList theToolkit thePackages)
  OCCDoc_GetRootDir(theRoot)
  # Open file with list of packages of the given toolkit
  set(CONTENT "")
  if(EXISTS "${theRoot}/src/${theToolkit}/PACKAGES")
    file(STRINGS "${theRoot}/src/${theToolkit}/PACKAGES" CONTENT)
  endif()
  set(${thePackages} "${CONTENT}" PARENT_SCOPE)
endfunction()

# Function to get toolkits dependencies from file src/TOOLKIT_NAME/EXTERNLIB.
# Creates <TOOLKIT_NAME>_DEPS variable to store them.
function (OCCT_TOOLKIT_DEP TOOLKIT_NAME)
  if (BUILD_PATCH_DIR AND EXISTS "${BUILD_PATCH_DIR}/src/${TOOLKIT_NAME}/EXTERNLIB")
    set (MODULE_PATH_PREFIX ${BUILD_PATCH_DIR})
  elseif (EXISTS "${CMAKE_SOURCE_DIR}/src/${TOOLKIT_NAME}/EXTERNLIB")
    set (MODULE_PATH_PREFIX ${CMAKE_SOURCE_DIR})
  else()
    RETURN()
  endif()
  file (STRINGS "${MODULE_PATH_PREFIX}/src/${TOOLKIT_NAME}/EXTERNLIB" CONTENT)
  set (${TOOLKIT_NAME}_DEPS ${CONTENT} PARENT_SCOPE)
endfunction()

# Function to determine if TOOLKIT is OCC toolkit
# Creates "isFOUND" variable to store result
function (IS_OCCT_TOOLKIT TOOLKIT_NAME)
  set (isFOUND -1 PARENT_SCOPE)
  GET_OCCT_MODULES(MODULES)
  foreach(MODULE ${MODULES})
    set(TOOLKITS ${${MODULE}_TOOLKITS})
    list(FIND TOOLKITS ${TOOLKIT_NAME} isOK)
    if (NOT ${isOK} EQUAL -1)
      set (isFOUND "${MODULE}" PARENT_SCOPE)
      return()
    endif()
  endforeach(MODULE)
endfunction()

# Function to get list of modules and toolkits from file adm/MODULES.
# Creates list <${MODULES_LIST}> to store list of MODULES and
# <NAME_OF_MODULE>_TOOLKITS foreach module to store its toolkits.
function (GET_OCCT_MODULES MODULES_LIST)
  set (MODULE_PATH_POSTFIX "/adm/MODULES")
  if (BUILD_PATCH_DIR AND EXISTS "${BUILD_PATCH_DIR}${MODULE_PATH_POSTFIX}")
    set (MODULE_PATH_PREFIX "${BUILD_PATCH_DIR}")
  elseif (EXISTS "${CMAKE_SOURCE_DIR}${MODULE_PATH_POSTFIX}")
    set (MODULE_PATH_PREFIX "${CMAKE_SOURCE_DIR}")
  else()
    RETURN()
  endif()

  file (STRINGS "${MODULE_PATH_PREFIX}${MODULE_PATH_POSTFIX}" CONTENT)

  set (${MODULES_LIST})
  foreach (CONTENT_LINE ${CONTENT})
    string (REPLACE " " ";" CONTENT_LINE ${CONTENT_LINE})
    list (GET CONTENT_LINE 0 NAME_OF_MODULE)
    list (REMOVE_AT CONTENT_LINE 0)
    list (APPEND ${MODULES_LIST} ${NAME_OF_MODULE})
    set (${NAME_OF_MODULE}_TOOLKITS "${CONTENT_LINE}" PARENT_SCOPE)
  endforeach()

  set (${MODULES_LIST} ${${MODULES_LIST}} PARENT_SCOPE)
endfunction()

# Gets contents of the given html node (for Post-processing)
function(OCCDoc_GetNodeContents node props html theResult)
  set (openTag "<${node}${props}>")
  set (closingTag "</${node}>")
  string(FIND "${html}" "${openTag}" start)
  if (${start} EQUAL -1)
    set(theResult "" PARENT_SCOPE)
    return()
  endif()
  string(LENGTH "${openTag}" length)
  math(EXPR start "${start} + ${length}")
  string(SUBSTRING "${html}" ${start} -1 html)
  string(FIND "${html}" "${closingTag}" start)
  if (${start} EQUAL -1)
    set(theResult "" PARENT_SCOPE)
    return()
  endif()
  math(EXPR start "${start} - 1")
  string(SUBSTRING "${html}" 0 ${start} theResult)
  set(theResult "" PARENT_SCOPE)
endfunction()

# Generates main page file describing module structure
function (OCCDoc_MakeMainPage outDir outFile inModules)
  set(inModules "${${inModules}}")
  #env
  set (module_prefix "module_")
  set (toolkit_prefix "toolkit_")
  set (package_prefix "package_")

  if (NOT EXISTS "${outDir}/html")
    file(MAKE_DIRECTORY "${outDir}/html")
  endif()

  OCCDoc_LoadData()
  # Main page: list of modules
  separate_arguments(inModules)
  list(LENGTH inModules length)
  if (NOT ${length} EQUAL 1)
    puts (${outFile} "/**")
    puts (${outFile} "\\mainpage Open CASCADE Technology")
    foreach (mod ${inModules})
      string(TOLOWER "${module_prefix}${mod}" LowerString)
      puts (${outFile} "\\li \\subpage ${LowerString}")
    endforeach()
    OCCDoc_CreateModulesDependencyGraph("${outDir}/html" "schema_all_modules" inModules ${module_prefix})
    # insert modules relationship diagramm
    puts (${outFile} "\\dotfile schema_all_modules")
    puts (${outFile} "**/")
  endif()

  # One page per module: list of toolkits
  set (toolkits)
  foreach (mod ${inModules})
    puts (${outFile} "/**")
    if (${length} EQUAL 1)
        puts (${outFile} "\\mainpage OCCT Module ${mod}")
    else()
        string(TOLOWER "module_${mod}" LowerString)
        puts (${outFile} "\\page ${LowerString} Module ${mod}")
    endif()
    list(SORT ${mod}_TOOLKITS)
    foreach (tk ${${mod}_TOOLKITS})
      OCC_GetUnitType("${tk}" theType)
      if("${theType}" STREQUAL "t")
        list(APPEND toolkits ${tk})
        string(TOLOWER "${toolkit_prefix}${tk}" LowerString)
        puts (${outFile} "\\li \\subpage ${LowerString}")
      endif()
    endforeach()
    OCCDoc_CreateModuleToolkitsDependencyGraph("${outDir}/html" "schema_${mod}" ${mod} ${toolkit_prefix})
    puts (${outFile} "\\dotfile schema_${mod}")
    puts (${outFile} "**/")
  endforeach()

  # One page per toolkit: list of packages
  set (packages)
  foreach (tk ${toolkits})
    puts (${outFile} "/**")
    string(TOLOWER "toolkit_${tk}" LowerString)
    puts (${outFile} "\\page ${LowerString} Toolkit ${tk}")
    OCCDoc_GetPackagesList(${tk} ${tk}_PACKAGES)
    list(SORT ${tk}_PACKAGES)
    foreach (pk ${${tk}_PACKAGES})
      list(APPEND packages ${pk})
      string(TOLOWER "${package_prefix}${pk}" LowerString)
      puts (${outFile} "\\li \\subpage ${LowerString}")
    endforeach()
    OCCDoc_CreateToolkitDependencyGraph("${outDir}/html" "schema_${tk}" "${tk}" "${toolkit_prefix}")
    puts (${outFile} "\\dotfile schema_${tk}")
    puts (${outFile} "**/")
  endforeach()

  # One page per package: list of classes
  foreach (pk ${packages})
    puts (${outFile} "/**")
    string(TOLOWER "${package_prefix}${pk}" LowerString)
    puts (${outFile} "\\page ${LowerString} Package ${pk}")
    file(GLOB INC_FILES RELATIVE "${theRoot}/src/${pk}" "${theRoot}/src/${pk}/*.hxx")
    foreach (hdr ${INC_FILES})
      string(FIND "${hdr}" "Handle_" isHandle)
      if(NOT ${isHandle} EQUAL 0)
        string(LENGTH "${hdr}" length)
        math(EXPR length "${length} - 4")
        string(SUBSTRING "${hdr}" 0 ${length} aName)
        puts (${outFile} "\\li \\subpage ${aName}")
      endif()
    endforeach()
    puts (${outFile} "**/")
  endforeach()
endfunction()

# Parses generated files to add a navigation path
function(OCCDoc_PostProcessor outDir)
  string(TIMESTAMP time "%Y-%m-%d %H:%M")
  puts("${time} Post-process is started ...")
  set(outDir "${outDir}/html")
  file(GLOB files "${outDir}/package_*")
  list(LENGTH files length)
  if (NOT ${length} EQUAL 0)
    list(SORT files)
    foreach(f ${files})
      file(READ ${f} packageFile)
      OCCDoc_GetNodeContents("div" " id=\"nav-path\" class=\"navpath\"" "${packageFile}" navPath)
      OCCDoc_GetNodeContents("div" " class=\"title\"" "${packageFile}" packageName)
      get_filename_component(packageFileName "${f}" NAME)
      # add package link to nav path
      string(REPLACE "</ul>" "" navPath "${navPath}")
      set (navPath "${navPath}  <li class=\"navelem\"><a class=\"el\" href=\"${packageFileName}\">${packageName}</a>      </li>\n    </ul>")
      # get list of files to update
      OCCDoc_GetNodeContents("div" " class=\"textblock\"" "${packageFile}" listContents)
      OCCDoc_GetNodeContents("ul" "" "${listContents}" listContents)
      foreach(line ${listContents})
        STRING(REGEX REPLACE ".*href=\"([^\"]+)\".*" "\\1" classFileName "${test}" )
        if (NOT "${classFileName}" STREQUAL "${line}")
          # check if anchor is there
          string(FIND "${classFileName}" "#" anchorPos)
          if (NOT ${anchorPos} EQUAL -1)
            math(EXPR anchorPos "${anchorPos} - 1")
            string(SUBSTRING "${classFileName}" 0 ${anchorPos} classFileName)
          endif()

          # read class file
          set (classFilePnt "${outDir}/${classFileName}")
          file(READ ${classFilePnt} classFile)

          # find position of content block
          string(FIND "${classFile}" "<div class=\"header\">" contentPos)
          math(EXPR contentPos "${contentPos} - 1")
          string(SUBSTRING "${classFile}" 0 ${contentPos} navPart)

          # position where to insert nav path
          string(FIND "${navPart}" "</div>" posToInsert REVERSE)
          math(EXPR posToInsert "${posToInsert} - 1")
          string(SUBSTRING "${classFile}" 0 ${posToInsert} prePart)
          string(SUBSTRING "${classFile}" ${posToInsert} -1 postPart)
          list(APPEND newClassFile "${prePart}" "  <div id=\"nav-path\" class=\"navpath\">" "${navPath}" "\n" "  </div>" "\n" "${postPart}")

          # write updated content
          file(WRITE ${classFilePnt} "${newClassFile}")
          file(APPEND ${classFilePnt} "${classFile}")
        endif()
      endforeach()
    endforeach()
  else()
    puts ("no files found")
  endif()
endfunction()

# ======================================
#  User Guides-specific functions
# ======================================

# Loads a list of docfiles from file FILES.txt
function(OCCDoc_LoadFilesList)
  OCCDoc_GetDoxDir(INPUTDIR)

  #available_docfiles
  set (available_docfiles "")
  # Read data from file
  if ( EXISTS "${INPUTDIR}/FILES_HTML.txt" )
    file (STRINGS "${INPUTDIR}/FILES_HTML.txt" available_docfiles REGEX "^[^#]+")
  else()
    error("File FILES_HTML.txt was not found on this computer.\nAborting...")
  endif()
  set(available_docfiles "${available_docfiles}" PARENT_SCOPE)

  #available_pdf
  set(available_pdf "")
  # Read data from file
  if ( EXISTS "${INPUTDIR}/FILES_PDF.txt" )
    file (STRINGS "${INPUTDIR}/FILES_PDF.txt" available_pdf REGEX "^[^#]+")
  else()
    error("File FILES_PDF.txt was not found on this computer.\nAborting...")
  endif()
  set(available_pdf "${available_pdf}" PARENT_SCOPE)
endfunction()

# Writes new TeX file for conversion from tex to pdf for a specific doc
function(OCCDoc_MakeRefmanTex fileName latexDir verboseMode latexFilesList)
  set(latexFilesList ${${latexFilesList}})
  if ( "${verboseMode}" STREQUAL "YES")
    puts ("Info: Making refman.tex file for ${fileName}...")
  endif()
  set (DOCNAME "${latexDir}/refman.tex")
  if (EXISTS ${DOCNAME})
    file(REMOVE ${DOCNAME})
  endif()

  # Copy template file to latex folder
  OCCDoc_GetDoxDir(temp_path)

  configure_file("${temp_path}/resources/occt_pdf_template.tex" "${DOCNAME}" COPYONLY)

  # Get templatized data
  file(READ ${DOCNAME} texfile_loaded)

  # Replace dummy values
  OCCDoc_DetectCasVersion(casVersion)

  # Get name of the document
  set (docLabel "")
  foreach (aFileName ${latexFilesList})
    # Find the file in FILES_PDF.txt
    string(REPLACE "/" ";" parsedFileName "${aFileName}")
    separate_arguments(parsedFileName)
    string(FIND "${fileName}" "__" aFirst)
    math(EXPR aFirst "${aFirst} + 2")
    string(SUBSTRING "${fileName}" ${aFirst} -1 newfileName)
    list(FIND parsedFileName "${newfileName}.md" isFOUND)
    if (NOT ${isFOUND} EQUAL -1)
      OCCDoc_GetDoxDir(temp_path)
      set (filepath "${temp_path}/${aFileName}")
      if (EXISTS ${filepath})
        file(STRINGS "${filepath}" MDFile LIMIT_COUNT 1)
        string(REPLACE "{" ";" MDFile "${MDFile}")
        separate_arguments(MDFile)
        list(GET MDFile 0 label)
        set (docLabel "${label}")
        break()
      endif()
    endif()
  endforeach()
  string(TIMESTAMP curYear "%Y")
  string(REPLACE "DEFDOCLABEL" "${docLabel}" texfile_loaded "${texfile_loaded}")
  string(REPLACE "DEFCASVERSION" "${casVersion}" texfile_loaded "${texfile_loaded}")
  string(REPLACE "DEFFILENAME" "${fileName}" texfile_loaded "${texfile_loaded}")
  string(REPLACE "DEFYEAR" "${curYear}" texfile_loaded "${texfile_loaded}")
  # Get data
  file(WRITE ${DOCNAME} "${texfile_loaded}")
endfunction()

# Postprocesses generated TeX files
function(OCCDoc_ProcessTex texFiles latexDir verboseMode)
  set(texFiles ${${texFiles}})
  foreach (TEX ${texFiles})
    if ("${verboseMode}" STREQUAL "YES")
      puts("Info: Preprocessing file ${TEX}...")
    endif()

    if (NOT EXISTS ${latexDir}/${TEX})
      error("Error: file ${TEX} does not exist.")
    endif()

    file(STRINGS "${latexDir}/${TEX}" IN_F)
    set(TEMP_LIST)
    foreach(line ${IN_F})
      string(FIND "${line}" "\\includegraphics" includegraphicsPos)
      string(FIND "${line}" "\\subsection" subsectionPos)
      string(FIND "${line}" "\\subsubsection" subsubsectionPos)
      string(FIND "${line}" "\\paragraph" paragraphPos)

      if (NOT ${includegraphicsPos} EQUAL -1)
        # replace svg extension by pdf
        string(REPLACE ".svg" ".pdf" line "${line}")
        # Center images in TeX files
        set(line "\\begin{center}\n ${line}\n\\end{center}")
      elseif (NOT ${subsectionPos} EQUAL -1)
          # Replace \subsection with \section tag
          string(REPLACE "\\\\subsection" "\\\\section" line "${line}")
      elseif (NOT ${subsubsectionPos} EQUAL -1)
          # Replace \subsubsection with \subsection tag
          string(REPLACE "\\\\subsubsection" "\\\\subsection" line "${line}")
      elseif (NOT ${paragraphPos} EQUAL -1)
          # Replace \paragraph with \subsubsection tag
          string(REPLACE "\\\\paragraph" "\\\\subsubsection" line "${line}")
      endif()
      list(APPEND TEMP_LIST "${line}")
    endforeach()
    file(WRITE "${latexDir}/${TEX}" ${TEMP_LIST})
  endforeach()
endfunction()
